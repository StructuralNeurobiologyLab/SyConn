<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>syconn.processing.features &#8212; SyConn a documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     'a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="top" title="SyConn a documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SyConn a documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for syconn.processing.features</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># SyConn - Synaptic connectivity inference toolkit</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2016 - now</span>
<span class="c1"># Max-Planck-Institute for Medical Research, Heidelberg, Germany</span>
<span class="c1"># Authors: Sven Dorkenwald, Philipp Schubert, JÃ¶rgen Kornfeld</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">zipfile</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">arr</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">spatial</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">learning_rfc</span> <span class="k">import</span> <span class="n">write_feat2csv</span><span class="p">,</span> <span class="n">cell_classification</span>
<span class="kn">from</span> <span class="nn">knossos_utils</span> <span class="k">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">..utils.basics</span> <span class="k">import</span> <span class="n">euclidian_distance</span>
<span class="kn">from</span> <span class="nn">..utils.datahandler</span> <span class="k">import</span> <span class="n">load_objpkl_from_kzip</span><span class="p">,</span> \
    <span class="n">load_ordered_mapped_skeleton</span>
<span class="kn">from</span> <span class="nn">knossos_utils.skeleton</span> <span class="k">import</span> <span class="n">remove_from_zip</span>


<div class="viewcode-block" id="update_property_feat_kzip_star"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.update_property_feat_kzip_star">[docs]</a><span class="k">def</span> <span class="nf">update_property_feat_kzip_star</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function for update_property_feat_kzip</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">update_property_feat_kzip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="update_property_feat_kzip"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.update_property_feat_kzip">[docs]</a><span class="k">def</span> <span class="nf">update_property_feat_kzip</span><span class="p">(</span><span class="n">path2kzip</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">6000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recompute axoness feature of skeleton at path2kzip and writes it to</span>
<span class="sd">    .k.zip</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path2kzip : str</span>
<span class="sd">        Path to mapped skeleton</span>
<span class="sd">    dist : int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prop_dict</span><span class="p">,</span> <span class="n">property_feat_names</span> <span class="o">=</span> <span class="n">calc_prop_feat_dict</span><span class="p">(</span><span class="n">path2kzip</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">prop</span><span class="p">,</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">prop_dict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">path2csv</span> <span class="o">=</span> <span class="n">path2kzip</span><span class="p">[:</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">%s</span><span class="s1">_feat.csv&#39;</span> <span class="o">%</span> <span class="n">prop</span>
        <span class="n">write_feat2csv</span><span class="p">(</span><span class="n">path2csv</span><span class="p">,</span> <span class="n">feat</span><span class="p">,</span> <span class="n">property_feat_names</span><span class="p">[</span><span class="n">prop</span><span class="p">])</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_feat.csv&#39;</span> <span class="o">%</span> <span class="n">prop</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">remove_from_zip</span><span class="p">(</span><span class="n">path2kzip</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="n">path2kzip</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_DEFLATED</span><span class="p">)</span> <span class="k">as</span> <span class="n">zf</span><span class="p">:</span>
                <span class="n">zf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">path2csv</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
            <span class="c1"># print &quot;Wrote new %s feature to %s.&quot; % (prop, path2kzip)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Could not write </span><span class="si">%s</span><span class="s1"> to zip file.&#39;</span> <span class="o">%</span> <span class="n">file_name</span>
            <span class="nb">print</span> <span class="n">e</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">path2csv</span><span class="p">)</span></div>


<div class="viewcode-block" id="calc_prop_feat_dict"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.calc_prop_feat_dict">[docs]</a><span class="k">def</span> <span class="nf">calc_prop_feat_dict</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">6000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates property feature</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source : SkeletonAnnotation</span>
<span class="sd">    dist : int</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict, list of str, bool</span>
<span class="sd">    Dictionary of property features, list of feature names, bool if spiness</span>
<span class="sd">    feature are given</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">property_features</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">property_feat_names</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">morph_feat</span><span class="p">,</span> <span class="n">spinehead_feats</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span> <span class="n">spiness_given</span>\
        <span class="o">=</span> <span class="n">morphology_feature</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
    <span class="n">morph_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">node_ids</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span>
                                 <span class="n">morph_feat</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">property_features</span><span class="p">[</span><span class="s2">&quot;axoness&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">morph_info</span><span class="p">,</span>
                                                  <span class="n">spinehead_feats</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">morph_feat_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nodeID&#39;</span><span class="p">,</span> <span class="s1">&#39;rad_mean&#39;</span><span class="p">,</span> <span class="s1">&#39;rad_std&#39;</span><span class="p">]</span> <span class="o">+</span> \
                       <span class="p">[</span><span class="s1">&#39;rad_hist&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span> <span class="o">+</span>\
                       <span class="p">[</span><span class="s1">&#39;mito_nb&#39;</span><span class="p">,</span> <span class="s1">&#39;mito_size_mean&#39;</span><span class="p">,</span> <span class="s1">&#39;vc_nb&#39;</span><span class="p">,</span> <span class="s1">&#39;vc_size_mean&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;sj_nb&#39;</span><span class="p">,</span> <span class="s1">&#39;sj_size_mean&#39;</span><span class="p">,</span> <span class="s1">&#39;branch_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;endpoint_dist&#39;</span><span class="p">]</span>
    <span class="n">property_features</span><span class="p">[</span><span class="s2">&quot;spiness&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">morph_info</span>
    <span class="n">property_feat_names</span><span class="p">[</span><span class="s2">&quot;axoness&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">morph_feat_names</span> <span class="o">+</span>\
                                    <span class="p">[</span><span class="s1">&#39;nb_spinehead&#39;</span><span class="p">,</span> <span class="s1">&#39;sh_rad_mean&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;sh_rad_std&#39;</span><span class="p">,</span> <span class="s1">&#39;sh_proba_mean&#39;</span><span class="p">]</span>
    <span class="n">property_feat_names</span><span class="p">[</span><span class="s2">&quot;spiness&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">morph_feat_names</span>
    <span class="k">return</span> <span class="n">property_features</span><span class="p">,</span> <span class="n">property_feat_names</span><span class="p">,</span> <span class="n">spiness_given</span></div>


<div class="viewcode-block" id="morphology_feature"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.morphology_feature">[docs]</a><span class="k">def</span> <span class="nf">morphology_feature</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">max_nn_dist</span><span class="o">=</span><span class="mi">6000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates features for discrimination tasks of neurite identities, such as</span>
<span class="sd">    axon vs. dendrite or cell types classification. Estimated on interpolated</span>
<span class="sd">    skeleton nodes. Features are calculated with a sliding window approach for</span>
<span class="sd">    each node. Window is 2*max_nn_dist (nm).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source : str</span>
<span class="sd">        Path to anno or MappedSkeletonObject</span>
<span class="sd">    max_nn_dist : float</span>
<span class="sd">        Radius in which neighboring nodes are found and</span>
<span class="sd">        used for calculating features in nm.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.array, numpary.array, list of int, bool</span>
<span class="sd">        two arrays of features for each node. number of nodes x 28 (22 radius</span>
<span class="sd">        feature and 6 object features), bool if spiness feature are given</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
        <span class="n">anno</span> <span class="o">=</span> <span class="n">load_ordered_mapped_skeleton</span><span class="p">(</span><span class="n">source</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># build mito sample tree</span>
        <span class="n">mitos</span><span class="p">,</span> <span class="n">vc</span><span class="p">,</span> <span class="n">sj</span> <span class="o">=</span> <span class="n">load_objpkl_from_kzip</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">anno</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">old_anno</span>
        <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">mitos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mitos</span><span class="p">,</span> <span class="n">vc</span><span class="p">,</span> <span class="n">sj</span> <span class="o">=</span> <span class="n">load_objpkl_from_kzip</span><span class="p">(</span><span class="n">anno</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mitos</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">mitos</span>
            <span class="n">vc</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">vc</span>
            <span class="n">sj</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">sj</span>
    <span class="n">m_dict</span><span class="p">,</span> <span class="n">vc_dict</span><span class="p">,</span> <span class="n">sj_dict</span> <span class="o">=</span> <span class="p">(</span><span class="n">mitos</span><span class="o">.</span><span class="n">object_dict</span><span class="p">,</span> <span class="n">vc</span><span class="o">.</span><span class="n">object_dict</span><span class="p">,</span>
                                <span class="n">sj</span><span class="o">.</span><span class="n">object_dict</span><span class="p">)</span>
    <span class="n">nearby_node_list</span> <span class="o">=</span> <span class="n">nodes_in_pathlength</span><span class="p">(</span><span class="n">anno</span><span class="p">,</span> <span class="n">max_nn_dist</span><span class="p">)</span>
    <span class="n">node_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">node_radii</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">node_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">nearby_node_list</span><span class="p">:</span>
        <span class="n">node_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">())</span>
        <span class="n">node_radii</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getDataElem</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">))</span>
        <span class="n">node_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getID</span><span class="p">())</span>
    <span class="n">m_feat</span> <span class="o">=</span> <span class="n">objfeat2skelnode</span><span class="p">(</span><span class="n">node_coords</span><span class="p">,</span> <span class="n">node_radii</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span>
                              <span class="n">nearby_node_list</span><span class="p">,</span> <span class="n">m_dict</span><span class="p">,</span> <span class="n">anno</span><span class="o">.</span><span class="n">scaling</span><span class="p">)</span>
    <span class="n">vc_feat</span> <span class="o">=</span> <span class="n">objfeat2skelnode</span><span class="p">(</span><span class="n">node_coords</span><span class="p">,</span> <span class="n">node_radii</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span>
                               <span class="n">nearby_node_list</span><span class="p">,</span> <span class="n">vc_dict</span><span class="p">,</span> <span class="n">anno</span><span class="o">.</span><span class="n">scaling</span><span class="p">)</span>
    <span class="n">sj_feat</span> <span class="o">=</span> <span class="n">objfeat2skelnode</span><span class="p">(</span><span class="n">node_coords</span><span class="p">,</span> <span class="n">node_radii</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span>
                               <span class="n">nearby_node_list</span><span class="p">,</span> <span class="n">sj_dict</span><span class="p">,</span> <span class="n">anno</span><span class="o">.</span><span class="n">scaling</span><span class="p">)</span>
    <span class="n">rad_feat</span><span class="p">,</span> <span class="n">spinehead_feat</span><span class="p">,</span> <span class="n">spiness_given</span> <span class="o">=</span> <span class="n">radfeat2skelnode</span><span class="p">(</span><span class="n">nearby_node_list</span><span class="p">)</span>
    <span class="n">morph_feat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">rad_feat</span><span class="p">,</span> <span class="n">m_feat</span><span class="p">,</span> <span class="n">vc_feat</span><span class="p">,</span> <span class="n">sj_feat</span><span class="p">),</span>
                                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dist_feature</span><span class="p">,</span> <span class="n">ids</span> <span class="o">=</span> <span class="n">node_branch_end_distance</span><span class="p">(</span><span class="n">anno</span><span class="p">,</span> <span class="n">max_nn_dist</span><span class="p">)</span>
    <span class="n">sort_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">sort_ix</span><span class="p">]</span>
    <span class="n">dist_feature</span> <span class="o">=</span> <span class="n">dist_feature</span><span class="p">[</span><span class="n">sort_ix</span><span class="p">]</span>
    <span class="n">node_ids</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span>
    <span class="n">sort_ix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span>
    <span class="n">node_ids</span> <span class="o">=</span> <span class="n">node_ids</span><span class="p">[</span><span class="n">sort_ix2</span><span class="p">]</span>
    <span class="n">morph_feat</span> <span class="o">=</span> <span class="n">morph_feat</span><span class="p">[</span><span class="n">sort_ix2</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">node_ids</span> <span class="o">==</span> <span class="n">ids</span><span class="p">),</span> <span class="s1">&#39;Node IDs are different.&#39;</span>
    <span class="n">morph_feat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">morph_feat</span><span class="p">,</span> <span class="n">dist_feature</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">morph_feat</span><span class="p">)):</span>
        <span class="c1"># print &quot;Found nans in morphological features of %s: %s&quot; % \</span>
        <span class="c1">#       (source, np.where(np.isnan(morph_feat)))</span>
        <span class="n">morph_feat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">morph_feat</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
    <span class="n">spinehead_feat</span> <span class="o">=</span> <span class="n">spinehead_feat</span><span class="p">[</span><span class="n">sort_ix2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">spinehead_feat</span><span class="p">)):</span>
        <span class="c1"># print &quot;Found nans in spinhead features of %s: %s&quot; % \</span>
        <span class="c1">#       (source, np.where(np.isnan(spinehead_feat)))</span>
        <span class="n">spinehead_feat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">spinehead_feat</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">morph_feat</span><span class="p">,</span> <span class="n">spinehead_feat</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">spiness_given</span></div>


<div class="viewcode-block" id="radfeat2skelnode"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.radfeat2skelnode">[docs]</a><span class="k">def</span> <span class="nf">radfeat2skelnode</span><span class="p">(</span><span class="n">nearby_node_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate nodewise radius feature</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nearby_node_list : list of list of SkeletonNodes</span>
<span class="sd">        grouped tracing nodes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array, np.array, bool</span>
<span class="sd">        array of number of nodes times 22 features, containing mean radius,</span>
<span class="sd">        sigma of radii, 20 hist features, spinehead features and whether</span>
<span class="sd">        spiness features are returned</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">radius_feat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nearby_node_list</span><span class="p">),</span> <span class="mi">12</span><span class="p">))</span>
    <span class="n">spiness_given</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">nearby_node_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;spiness_pred&quot;</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># print &quot;Spiness prediction not found in Annotation Object. Axoness&quot; \</span>
        <span class="c1">#       &quot;feature reduced to morphological features.&quot;</span>
        <span class="n">spiness_given</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">spinehead_feats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nearby_node_list</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">neighbor_nodes</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nearby_node_list</span><span class="p">):</span>
        <span class="n">radius_feat</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">radius_feats_from_nodes</span><span class="p">(</span><span class="n">neighbor_nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spiness_given</span><span class="p">:</span>
            <span class="n">spinehead_feats</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spiness_feats_from_nodes</span><span class="p">(</span><span class="n">neighbor_nodes</span><span class="p">)[:</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">radius_feat</span><span class="p">,</span> <span class="n">spinehead_feats</span><span class="p">,</span> <span class="n">spiness_given</span></div>


<div class="viewcode-block" id="radius_feats_from_nodes"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.radius_feats_from_nodes">[docs]</a><span class="k">def</span> <span class="nf">radius_feats_from_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">nb_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_rad</span><span class="o">=</span><span class="mi">5000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates mean, std and histogram features</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nodes : list of SkeletonNodes</span>
<span class="sd">    nb_bins : int</span>
<span class="sd">        Number of bins for histogram features</span>
<span class="sd">    max_rad : int</span>
<span class="sd">        maximum radius to plot on histogram x-axis</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        radius features with dim. nb_bins+2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">radius_feat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span><span class="p">))</span>
    <span class="n">nn_radius</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">nn</span><span class="o">.</span><span class="n">getDataElem</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>
    <span class="n">radius_feat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nn_radius</span><span class="p">)</span>
    <span class="n">radius_feat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">nn_radius</span><span class="p">)</span>
    <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">nn_radius</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">nb_bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_rad</span><span class="p">),</span>
                                   <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">radius_feat</span><span class="p">[</span><span class="mi">2</span><span class="p">:(</span><span class="n">nb_bins</span><span class="o">+</span><span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">hist</span>
    <span class="k">return</span> <span class="n">radius_feat</span></div>


<div class="viewcode-block" id="spiness_feats_from_nodes"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.spiness_feats_from_nodes">[docs]</a><span class="k">def</span> <span class="nf">spiness_feats_from_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates spiness feats including abs. number of spineheads, mean and</span>
<span class="sd">    standard deviation (std) of spinehead size, mean spinehead probability and</span>
<span class="sd">    mean and std of spineneck lengths.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nodes : list of SkeletonNodes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        spiness features, dim. of 6</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spinehead_feats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">))</span>
    <span class="n">spinehead_radius</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spinehead_proba</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spine_neck_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;spiness_pred&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">spinehead_proba</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;spiness_proba1&quot;</span><span class="p">]))</span>
            <span class="n">spinehead_radius</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">])</span>
            <span class="n">node1</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">neck_length</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">getParents</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">data</span>\
            <span class="p">[</span><span class="s2">&quot;spiness_pred&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">neck_length</span> <span class="o">+=</span> <span class="n">euclidian_distance</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">(),</span>
                               <span class="nb">list</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">getParents</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">())</span>
                <span class="n">node1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">getParents</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">spine_neck_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neck_length</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spinehead_radius</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">spinehead_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spinehead_radius</span><span class="p">)</span>
        <span class="n">spinhead_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">spinehead_radius</span><span class="p">)</span>
        <span class="n">spinehead_proba_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spinehead_proba</span><span class="p">)</span>
        <span class="n">spinehead_feats</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">spinehead_radius</span><span class="p">),</span> <span class="n">spinehead_mean</span><span class="p">,</span>
                               <span class="n">spinhead_std</span><span class="p">,</span> <span class="n">spinehead_proba_mean</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_neck_lengths</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">spinehead_feats</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spine_neck_lengths</span><span class="p">),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">spine_neck_lengths</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">spinehead_feats</span></div>


<div class="viewcode-block" id="sj_per_spinehead"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.sj_per_spinehead">[docs]</a><span class="k">def</span> <span class="nf">sj_per_spinehead</span><span class="p">(</span><span class="n">anno</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate number of sj per spinehead. Iterate over all mapped sj objects and</span>
<span class="sd">    find nearest skeleton node. If skeleton node has spiness prediction == 1</span>
<span class="sd">    (spinehead) then increment counter of this node by one.</span>
<span class="sd">    After the loop sum over all counter and divide by the number of nodes which</span>
<span class="sd">    have at least one sj assigned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param anno: SkeletonAnnotation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Average number of sj per spinehead (assumes there is no spinehead</span>
<span class="sd">        without sj)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sj</span> <span class="o">=</span> <span class="n">load_objpkl_from_kzip</span><span class="p">(</span><span class="n">anno</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">sj_dict</span> <span class="o">=</span> <span class="n">sj</span><span class="o">.</span><span class="n">object_dict</span>
    <span class="n">nb_sj</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sj_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">hull_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nb_sj</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">skel_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">anno</span><span class="o">.</span><span class="n">getNodes</span><span class="p">()]</span>
    <span class="n">node_coords</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">skel_nodes</span><span class="p">])</span>
    <span class="n">node_sj_counter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">skel_nodes</span><span class="p">),</span> <span class="p">))</span>
    <span class="n">skeleton_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">node_coords</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sj_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sj_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">sj</span> <span class="o">=</span> <span class="n">sj_dict</span><span class="p">[</span><span class="n">sj_key</span><span class="p">]</span>
        <span class="n">m_hull</span> <span class="o">=</span> <span class="n">sj</span><span class="o">.</span><span class="n">hull_voxels</span> <span class="o">*</span> <span class="n">arr</span><span class="p">(</span><span class="n">anno</span><span class="o">.</span><span class="n">scaling</span><span class="p">)</span>
        <span class="n">random_ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m_hull</span><span class="p">)),</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">hull_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_hull</span><span class="p">[</span><span class="n">random_ixs</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_sj</span><span class="p">):</span>
        <span class="n">dists</span><span class="p">,</span> <span class="n">nearest_skel_ixs</span> <span class="o">=</span> <span class="n">skeleton_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">hull_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">majority_ix</span> <span class="o">=</span> <span class="n">cell_classification</span><span class="p">(</span><span class="n">nearest_skel_ixs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">skel_nodes</span><span class="p">[</span><span class="n">majority_ix</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;spiness_pred&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">node_sj_counter</span><span class="p">[</span><span class="n">majority_ix</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">sj_per_sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">node_sj_counter</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">node_sj_counter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">sj_per_sh</span><span class="p">)</span></div>


<div class="viewcode-block" id="propertyfeat2skelnode"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.propertyfeat2skelnode">[docs]</a><span class="k">def</span> <span class="nf">propertyfeat2skelnode</span><span class="p">(</span><span class="n">node_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate nodewise radius feature</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node_list : list</span>
<span class="sd">        grouped nodes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        number of nodes times 22 features, containing mean radius,</span>
<span class="sd">        sigma of radii, 20 hist features</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">radius_feat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
    <span class="n">n_radius</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">type_feat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">n_axoness</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
        <span class="n">n_radius</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">getDataElem</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">)))</span>
        <span class="n">n_axoness</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;axoness_pred&quot;</span><span class="p">]))</span>
    <span class="n">n_radius</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">n_radius</span><span class="p">)</span>
    <span class="n">radius_feat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">n_radius</span><span class="p">)</span>
    <span class="n">radius_feat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">n_radius</span><span class="p">)</span>
    <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">n_radius</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5000</span><span class="p">),</span>
                                   <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">radius_feat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">hist</span>
    <span class="n">n_axoness</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">n_axoness</span><span class="p">)</span>
    <span class="n">nb_axonnodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n_axoness</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nb_dennodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n_axoness</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">nb_somanodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n_axoness</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">type_feat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nb_axonnodes</span><span class="p">,</span> <span class="n">nb_dennodes</span><span class="p">,</span> <span class="n">nb_somanodes</span><span class="p">]</span>
    <span class="n">type_feat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="n">type_feat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n_axoness</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">radius_feat</span><span class="p">,</span> <span class="n">type_feat</span></div>


<div class="viewcode-block" id="celltype_axoness_feature"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.celltype_axoness_feature">[docs]</a><span class="k">def</span> <span class="nf">celltype_axoness_feature</span><span class="p">(</span><span class="n">anno</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates axones feature of mapped sekeleton for cell type prediction.</span>
<span class="sd">    These include proportion of axon, dendrite and soma pathlengths and maximum</span>
<span class="sd">    degree of soma nodes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array (n x 4)</span>
<span class="sd">        axoness features</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">type_feats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">all_path_length</span> <span class="o">=</span> <span class="n">anno</span><span class="o">.</span><span class="n">physical_length</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1000.</span>
    <span class="k">if</span> <span class="n">all_path_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">type_feats</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pathlength_of_property</span><span class="p">(</span><span class="n">anno</span><span class="p">,</span> <span class="s1">&#39;axoness_pred&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> \
                            <span class="n">all_path_length</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">anno</span><span class="o">.</span><span class="n">getNodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;axoness_pred&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">type_feats</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">n</span><span class="o">.</span><span class="n">degree</span><span class="p">(),</span> <span class="n">type_feats</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">type_feats</span></div>


<div class="viewcode-block" id="pathlength_of_property"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.pathlength_of_property">[docs]</a><span class="k">def</span> <span class="nf">pathlength_of_property</span><span class="p">(</span><span class="n">anno</span><span class="p">,</span> <span class="nb">property</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate pathlength of nodes with certain property value</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    anno : SkeletonAnnotation</span>
<span class="sd">        mapped cell tracing</span>
<span class="sd">    property : str</span>
<span class="sd">        spiness / axoness</span>
<span class="sd">    value : int</span>
<span class="sd">        classification result, e.g. 0, 1, 2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        length (in um)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pathlength</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">anno</span><span class="o">.</span><span class="n">iter_edges</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">from_node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">property</span><span class="p">])</span> <span class="o">==</span> <span class="n">value</span> <span class="ow">and</span>\
                        <span class="nb">int</span><span class="p">(</span><span class="n">to_node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">property</span><span class="p">])</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">pathlength</span> <span class="o">+=</span> <span class="n">euclidian_distance</span><span class="p">(</span><span class="n">from_node</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">(),</span>
                                             <span class="n">to_node</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">pathlength</span> <span class="o">/</span> <span class="mf">1000.</span></div>


<div class="viewcode-block" id="objfeat2skelnode"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.objfeat2skelnode">[docs]</a><span class="k">def</span> <span class="nf">objfeat2skelnode</span><span class="p">(</span><span class="n">node_coords</span><span class="p">,</span> <span class="n">node_radii</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span> <span class="n">nearby_node_list</span><span class="p">,</span>
                     <span class="n">obj_dict</span><span class="p">,</span> <span class="n">scaling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate features of UltrastructuralDatasetObjects along Skeleton</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node_coords : np.array</span>
<span class="sd">    node_radii : np.array</span>
<span class="sd">    node_ids : np.array</span>
<span class="sd">    nearby_node_list : list of list of SkeletonNodes</span>
<span class="sd">    obj_dict : UltrastructuralDataset</span>
<span class="sd">    scaling : tuple</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array (dimension nb_skelnodes x 2)</span>
<span class="sd">        The two features are absolute number of assigned objects and</span>
<span class="sd">        mean voxel size of the objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skeleton_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">node_coords</span><span class="p">)</span>
    <span class="n">nb_skelnodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_coords</span><span class="p">)</span>
    <span class="n">axoness_features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nb_skelnodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">obj_assignment</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_skelnodes</span><span class="p">)]</span>
    <span class="n">nb_objs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">hull_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nb_objs</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">key_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obj_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">obj_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">obj_object</span> <span class="o">=</span> <span class="n">obj_dict</span><span class="p">[</span><span class="n">obj_key</span><span class="p">]</span>
        <span class="n">m_hull</span> <span class="o">=</span> <span class="n">obj_object</span><span class="o">.</span><span class="n">hull_voxels</span> <span class="o">*</span> <span class="n">scaling</span>
        <span class="n">random_ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m_hull</span><span class="p">)),</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">hull_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_hull</span><span class="p">[</span><span class="n">random_ixs</span><span class="p">]</span>
        <span class="n">key_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_key</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_objs</span><span class="p">):</span>
        <span class="n">dists</span><span class="p">,</span> <span class="n">nearest_skel_ixs</span> <span class="o">=</span> <span class="n">skeleton_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">hull_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nearest_skel_ixs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">nearest_skel_ixs</span> <span class="o">==</span> <span class="n">ix</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">node_radii</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">obj_assignment</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">key_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_skelnodes</span><span class="p">):</span>
        <span class="n">nn_nodes</span> <span class="o">=</span> <span class="n">nearby_node_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">nn_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">getID</span><span class="p">()</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">nn_nodes</span><span class="p">]</span>
        <span class="n">assigned_objs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nn_id</span> <span class="ow">in</span> <span class="n">nn_ids</span><span class="p">:</span>
            <span class="n">assigned_objs</span> <span class="o">+=</span> <span class="n">obj_assignment</span><span class="p">[</span><span class="n">node_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">nn_id</span><span class="p">)]</span>
        <span class="n">axoness_features</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">assigned_objs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assigned_objs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">obj_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">assigned_objs</span><span class="p">]</span>
        <span class="n">axoness_features</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">obj_sizes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">axoness_features</span></div>


<div class="viewcode-block" id="nodes_in_pathlength"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.nodes_in_pathlength">[docs]</a><span class="k">def</span> <span class="nf">nodes_in_pathlength</span><span class="p">(</span><span class="n">anno</span><span class="p">,</span> <span class="n">max_path_len</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find nodes reachable in max_path_len from source node, calculated for</span>
<span class="sd">    every node in anno.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    anno : AnnotationObject</span>
<span class="sd">    max_path_len : float</span>
<span class="sd">        Maximum distance from source node</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of lists containing reachable nodes in max_path_len where</span>
<span class="sd">    outer list has length len(anno.getNodes())</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skel_graph</span> <span class="o">=</span> <span class="n">su</span><span class="o">.</span><span class="n">annotation_to_nx_graph</span><span class="p">(</span><span class="n">anno</span><span class="p">)</span>
    <span class="n">list_reachable_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">source_node</span> <span class="ow">in</span> <span class="n">anno</span><span class="o">.</span><span class="n">getNodes</span><span class="p">():</span>
        <span class="n">source_node_coord</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">source_node</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">())</span>
        <span class="n">reachable_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">source_node</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">bfs_edges</span><span class="p">(</span><span class="n">skel_graph</span><span class="p">,</span> <span class="n">source_node</span><span class="p">):</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">next_node_coord</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">next_node</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">next_node_coord</span> <span class="o">-</span> <span class="n">source_node_coord</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_path_len</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">reachable_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
        <span class="n">list_reachable_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reachable_nodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">list_reachable_nodes</span></div>


<div class="viewcode-block" id="assign_property2node"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.assign_property2node">[docs]</a><span class="k">def</span> <span class="nf">assign_property2node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Assign prediction of property to node</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : NewSkeletonNode</span>
<span class="sd">    pred : prediction appropriate to property</span>
<span class="sd">    property : property to change</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_pred&quot;</span> <span class="o">%</span> <span class="nb">property</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
    <span class="n">node_comment</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">getComment</span><span class="p">()</span>
    <span class="n">ax_ix</span> <span class="o">=</span> <span class="n">node_comment</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">property</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax_ix</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">node</span><span class="o">.</span><span class="n">appendComment</span><span class="p">(</span><span class="nb">property</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pred</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">help_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_comment</span><span class="p">)</span>
        <span class="n">help_list</span><span class="p">[</span><span class="n">ax_ix</span><span class="o">+</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">setComment</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">help_list</span><span class="p">))</span></div>


<div class="viewcode-block" id="majority_vote"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.majority_vote">[docs]</a><span class="k">def</span> <span class="nf">majority_vote</span><span class="p">(</span><span class="n">anno</span><span class="p">,</span> <span class="nb">property</span><span class="o">=</span><span class="s1">&#39;axoness&#39;</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mi">6000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smoothes (average using sliding window of 2 times max_dist and majority</span>
<span class="sd">    vote) property prediction in annotation, whereas for axoness somata are</span>
<span class="sd">    untouched.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    anno : SkeletonAnnotation</span>
<span class="sd">    property : str</span>
<span class="sd">        which property to average</span>
<span class="sd">    max_dist : int</span>
<span class="sd">        maximum distance (in nm) for sliding window used in majority voting</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># print &quot;Performing smoothing of %s using sliding window average of max &quot; \</span>
    <span class="c1">#       &quot;dist %d nm.&quot; % (property, max_dist)</span>
    <span class="n">old_anno</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">anno</span><span class="p">)</span>
    <span class="n">nearest_nodes_list</span> <span class="o">=</span> <span class="n">nodes_in_pathlength</span><span class="p">(</span><span class="n">old_anno</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">nearest_nodes_list</span><span class="p">:</span>
        <span class="n">curr_node_id</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getID</span><span class="p">()</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">anno</span><span class="o">.</span><span class="n">getNodeByID</span><span class="p">(</span><span class="n">curr_node_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">new_node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;axoness_pred&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;axoness_pred&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">continue</span>
        <span class="n">property_val</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">property</span><span class="o">+</span><span class="s1">&#39;_pred&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">property_val</span><span class="p">)</span>
        <span class="n">new_ax</span> <span class="o">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">most_common</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node_comment</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">.</span><span class="n">getComment</span><span class="p">()</span>
        <span class="n">ax_ix</span> <span class="o">=</span> <span class="n">node_comment</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">property</span><span class="p">)</span>
        <span class="n">help_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_comment</span><span class="p">)</span>
        <span class="n">help_list</span><span class="p">[</span><span class="n">ax_ix</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nb">property</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_ax</span><span class="p">)</span>
        <span class="n">new_node</span><span class="o">.</span><span class="n">setComment</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">help_list</span><span class="p">))</span>
        <span class="n">new_node</span><span class="o">.</span><span class="n">setDataElem</span><span class="p">(</span><span class="nb">property</span><span class="o">+</span><span class="s1">&#39;_pred&#39;</span><span class="p">,</span> <span class="n">new_ax</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_obj_density"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.get_obj_density">[docs]</a><span class="k">def</span> <span class="nf">get_obj_density</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">property</span><span class="o">=</span><span class="s1">&#39;axoness_pred&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="s1">&#39;mito&#39;</span><span class="p">,</span>
                    <span class="n">return_abs_density</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate pathlength of nodes using edges</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    anno: list of SkeletonAnnotation</span>
<span class="sd">    property : str</span>
<span class="sd">        e.g. &#39;axoness_pred&#39;</span>
<span class="sd">    value : int</span>
<span class="sd">        value of property to check</span>
<span class="sd">    obj : str</span>
<span class="sd">        mito/vc/sj</span>
<span class="sd">    return_abs_density : bool</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :return: length in um</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mito&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;vc&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;sj&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
        <span class="n">anno</span> <span class="o">=</span> <span class="n">load_ordered_mapped_skeleton</span><span class="p">(</span><span class="n">source</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># build mito sample tree</span>
        <span class="n">mitos</span><span class="p">,</span> <span class="n">vc</span><span class="p">,</span> <span class="n">sj</span> <span class="o">=</span> <span class="n">load_objpkl_from_kzip</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">anno</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">old_anno</span>
        <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">mitos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mitos</span><span class="p">,</span> <span class="n">vc</span><span class="p">,</span> <span class="n">sj</span> <span class="o">=</span> <span class="n">load_objpkl_from_kzip</span><span class="p">(</span><span class="n">anno</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mitos</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">mitos</span>
            <span class="n">vc</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">vc</span>
            <span class="n">sj</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">sj</span>
    <span class="n">m_dict</span><span class="p">,</span> <span class="n">vc_dict</span><span class="p">,</span> <span class="n">sj_dict</span> <span class="o">=</span> <span class="p">(</span><span class="n">mitos</span><span class="o">.</span><span class="n">object_dict</span><span class="p">,</span> <span class="n">vc</span><span class="o">.</span><span class="n">object_dict</span><span class="p">,</span>
                                <span class="n">sj</span><span class="o">.</span><span class="n">object_dict</span><span class="p">)</span>
    <span class="n">obj_dict</span> <span class="o">=</span> <span class="p">[</span><span class="n">m_dict</span><span class="p">,</span> <span class="n">vc_dict</span><span class="p">,</span> <span class="n">sj_dict</span><span class="p">][</span><span class="n">obj_dict</span><span class="p">[</span><span class="n">obj</span><span class="p">]]</span>
    <span class="n">node_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">node_radii</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">node_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">anno</span><span class="o">.</span><span class="n">getNodes</span><span class="p">():</span>
        <span class="n">node_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">())</span>
        <span class="n">node_radii</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">getDataElem</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">))</span>
        <span class="n">node_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">getID</span><span class="p">())</span>
    <span class="n">pathlength</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nodes_of_value</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">anno</span><span class="o">.</span><span class="n">iter_edges</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">from_node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">property</span><span class="p">])</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">nodes_of_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">from_node</span><span class="o">.</span><span class="n">getID</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">from_node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">property</span><span class="p">])</span> <span class="o">==</span> <span class="n">value</span> <span class="ow">and</span>\
        <span class="nb">int</span><span class="p">(</span><span class="n">to_node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">property</span><span class="p">])</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">pathlength</span> <span class="o">+=</span> <span class="n">euclidian_distance</span><span class="p">(</span><span class="n">from_node</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">(),</span>
                                             <span class="n">to_node</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">())</span>
    <span class="n">skeleton_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">node_coords</span><span class="p">)</span>
    <span class="n">nb_skelnodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_coords</span><span class="p">)</span>
    <span class="n">obj_assignment</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_skelnodes</span><span class="p">)]</span>
    <span class="n">nb_objs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">hull_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nb_objs</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">key_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obj_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">obj_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">obj_object</span> <span class="o">=</span> <span class="n">obj_dict</span><span class="p">[</span><span class="n">obj_key</span><span class="p">]</span>
        <span class="n">m_hull</span> <span class="o">=</span> <span class="n">obj_object</span><span class="o">.</span><span class="n">hull_voxels</span> <span class="o">*</span> <span class="n">anno</span><span class="o">.</span><span class="n">scaling</span>
        <span class="n">random_ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m_hull</span><span class="p">)),</span> <span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
        <span class="n">hull_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_hull</span><span class="p">[</span><span class="n">random_ixs</span><span class="p">]</span>
        <span class="n">key_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_key</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_objs</span><span class="p">):</span>
        <span class="n">dists</span><span class="p">,</span> <span class="n">nearest_skel_ixs</span> <span class="o">=</span> <span class="n">skeleton_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">hull_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nearest_skel_ixs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">nearest_skel_ixs</span> <span class="o">==</span> <span class="n">ix</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">node_radii</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">obj_assignment</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">key_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">assigned_objs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_skelnodes</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node_ids</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="n">nodes_of_value</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">assigned_objs</span> <span class="o">+=</span> <span class="n">obj_assignment</span><span class="p">[</span><span class="n">node_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node_ids</span><span class="p">[</span><span class="n">k</span><span class="p">])]</span>
    <span class="n">assigned_objs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">assigned_objs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">pathlength</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">return_abs_density</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">assigned_objs</span><span class="p">)</span> <span class="o">/</span> <span class="n">pathlength</span> <span class="o">*</span> <span class="mf">1000.</span>
    <span class="n">obj_vols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">assigned_objs</span><span class="p">:</span>
        <span class="n">obj_vols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="p">(</span><span class="mi">9</span><span class="o">*</span><span class="mi">9</span><span class="o">*</span><span class="mi">20</span><span class="p">))</span>
    <span class="n">obj_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">obj_vols</span><span class="p">)</span> <span class="o">/</span> <span class="n">pathlength</span> <span class="o">*</span> <span class="mf">1000.</span>
    <span class="k">return</span> <span class="n">obj_density</span></div>


<div class="viewcode-block" id="node_branch_end_distance"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.features.node_branch_end_distance">[docs]</a><span class="k">def</span> <span class="nf">node_branch_end_distance</span><span class="p">(</span><span class="n">nml</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set distances to next branch resp. end point for each node (distance is</span>
<span class="sd">    capped by given parameter dist) in .data dictionary of each node</span>
<span class="sd">    and returns values with node ids</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nml : SkeletonAnnotation</span>
<span class="sd">    dist : int</span>
<span class="sd">        maximum distance value to occur</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array, np.array</span>
<span class="sd">        distances to nearest end/branch point, node ids</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">su</span><span class="o">.</span><span class="n">annotation_to_nx_graph</span><span class="p">(</span><span class="n">nml</span><span class="p">)</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="n">su</span><span class="o">.</span><span class="n">nx</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dic</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">bran</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dic</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">bran</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">Y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">getID</span><span class="p">())</span>
        <span class="n">node_to_all_endnode</span> <span class="o">=</span> <span class="p">[</span><span class="n">dist</span><span class="p">]</span>
        <span class="n">node_to_all_branchpoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">dist</span><span class="p">]</span>
        <span class="n">single_node_feature</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">endnode</span> <span class="ow">in</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">node_to_all_endnode</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">distance_scaled</span><span class="p">(</span><span class="n">endnode</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_to_all_endnode</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">distance2endpoint</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">node_to_all_endnode</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance2endpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">99999999</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;endpointdistance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance2endpoint</span>
        <span class="n">single_node_feature</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance2endpoint</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">branchpoint</span> <span class="ow">in</span> <span class="n">bran</span><span class="p">:</span>
            <span class="n">node_to_all_branchpoint</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">distance_scaled</span><span class="p">(</span><span class="n">branchpoint</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_to_all_branchpoint</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">distance2branchpoint</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">node_to_all_branchpoint</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance2branchpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">99999999</span><span class="p">)</span>
        <span class="n">single_node_feature</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance2branchpoint</span><span class="p">)</span>
        <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">single_node_feature</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;branchpointdistance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance2branchpoint</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SyConn a documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Sven Dorkenwald, Philipp Schubert, JÃ¶rgen Kornfeld.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.8.
    </div>
  </body>
</html>