<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>syconn.processing.mapper &#8212; SyConn a documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     'a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="top" title="SyConn a documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SyConn a documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for syconn.processing.mapper</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># SyConn - Synaptic connectivity inference toolkit</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2016 - now</span>
<span class="c1"># Max-Planck-Institute for Medical Research, Heidelberg, Germany</span>
<span class="c1"># Authors: Sven Dorkenwald, Philipp Schubert, JÃ¶rgen Kornfeld</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Manager</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">shutil</span> <span class="k">import</span> <span class="n">copyfile</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">stdout</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">axoness</span> <span class="k">import</span> <span class="n">majority_vote</span>
<span class="kn">from</span> <span class="nn">axoness</span> <span class="k">import</span> <span class="n">predict_axoness_from_nodes</span>
<span class="kn">from</span> <span class="nn">features</span> <span class="k">import</span> <span class="n">calc_prop_feat_dict</span>
<span class="kn">from</span> <span class="nn">learning_rfc</span> <span class="k">import</span> <span class="n">write_feat2csv</span>
<span class="kn">from</span> <span class="nn">spiness</span> <span class="k">import</span> <span class="n">assign_neck</span>
<span class="kn">from</span> <span class="nn">..utils.datahandler</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..utils.segmentationdataset</span> <span class="k">import</span> <span class="n">UltrastructuralDataset</span>
<span class="kn">from</span> <span class="nn">synapticity</span> <span class="k">import</span> <span class="n">parse_synfeature_from_node</span>
<span class="kn">from</span> <span class="nn">..multi_proc.multi_proc_main</span> <span class="k">import</span> <span class="n">start_multiprocess</span>
<span class="kn">from</span> <span class="nn">knossos_utils</span> <span class="k">import</span> <span class="n">chunky</span>
<span class="kn">from</span> <span class="nn">knossos_utils.knossosdataset</span> <span class="k">import</span> <span class="n">KnossosDataset</span>
<span class="kn">from</span> <span class="nn">sklearn.externals</span> <span class="k">import</span> <span class="n">joblib</span>
<span class="kn">from</span> <span class="nn">knossos_utils.skeleton</span> <span class="k">import</span> <span class="n">Skeleton</span>
<span class="kn">from</span> <span class="nn">knossos_utils.skeleton</span> <span class="k">import</span> <span class="n">SkeletonNode</span>
<span class="kn">from</span> <span class="nn">knossos_utils.skeleton</span> <span class="k">import</span> <span class="n">from_skeleton_to_mergelist</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">syconn.ray_casting.ray_casting_radius</span> <span class="k">import</span> <span class="n">ray_casting_radius</span>
    <span class="n">ray_cast_avail</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ray_casting_radius-module not imported&quot;</span><span class="p">)</span>
    <span class="n">ray_cast_avail</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="SkeletonMapper"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.SkeletonMapper">[docs]</a><span class="k">class</span> <span class="nc">SkeletonMapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to handle mapping of cell objects (mitochondria, vesicle clouds,</span>
<span class="sd">    synaptic clefts) to tracings. Mapping parameters are saved as attributes.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    soma : SkeletonAnnotation</span>
<span class="sd">        Soma tracing</span>
<span class="sd">    old_anno : SkeletonAnnotation</span>
<span class="sd">        original tracing where estimated cell radius is saved at each node</span>
<span class="sd">    anno : SkeletonAnnotation</span>
<span class="sd">        interpolated tracing skeleton for hull calculation</span>
<span class="sd">    mitos/vc/sj : segmentationDataset</span>
<span class="sd">        Dictionaries in which mapped cell objects are saved</span>
<span class="sd">    ix : int</span>
<span class="sd">        mapped skeleton id</span>
<span class="sd">    write_obj_voxel : bool</span>
<span class="sd">        write object voxel to kzip as binary file</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">ix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">soma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">context_range</span><span class="o">=</span><span class="mi">6000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source: SkeletonAnnotation/str</span>
<span class="sd">            initial tracing object or path to .k.zip file</span>
<span class="sd">        dh: DataHandler</span>
<span class="sd">            DataHandler object</span>
<span class="sd">        ix : int</span>
<span class="sd">            index of tracings</span>
<span class="sd">        soma : SkeletonAnnotation</span>
<span class="sd">            if additional soma tracing is available</span>
<span class="sd">        context_range : int</span>
<span class="sd">            range for feature extraction of spiness and axoness</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context_range</span> <span class="o">=</span> <span class="n">context_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">dh</span><span class="o">.</span><span class="n">scaling</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mem_path</span> <span class="o">=</span> <span class="n">dh</span><span class="o">.</span><span class="n">mem_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nb_cpus</span> <span class="o">=</span> <span class="n">dh</span><span class="o">.</span><span class="n">nb_cpus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cset_path</span> <span class="o">=</span> <span class="n">dh</span><span class="o">.</span><span class="n">cs_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_myelin_ds_path</span> <span class="o">=</span> <span class="n">dh</span><span class="o">.</span><span class="n">myelin_ds_path</span>
        <span class="n">init_anno</span> <span class="o">=</span> <span class="n">SkeletonAnnotation</span><span class="p">()</span>
        <span class="n">init_anno</span><span class="o">.</span><span class="n">scaling</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
        <span class="n">init_anno</span><span class="o">.</span><span class="n">appendComment</span><span class="p">(</span><span class="s1">&#39;soma&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">soma</span> <span class="o">=</span> <span class="n">init_anno</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mitos</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ix</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;[^/]+$&#39;</span><span class="p">,</span> <span class="n">source</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">source</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span> <span class="o">=</span> <span class="n">load_ordered_mapped_skeleton</span><span class="p">(</span><span class="n">source</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">anno</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">soma</span> <span class="o">=</span> <span class="n">load_ordered_mapped_skeleton</span><span class="p">(</span><span class="n">source</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
            <span class="n">obj_dicts</span> <span class="o">=</span> <span class="n">load_objpkl_from_kzip</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mitos</span> <span class="o">=</span> <span class="n">obj_dicts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vc</span> <span class="o">=</span> <span class="n">obj_dicts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sj</span> <span class="o">=</span> <span class="n">obj_dicts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">SkeletonAnnotation</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ix</span> <span class="o">=</span> <span class="n">ix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span> <span class="o">=</span> <span class="n">source</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">anno</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">soma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">soma</span> <span class="o">=</span> <span class="n">soma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Datatype not understood in __init__&#39;</span>
                               <span class="s1">&#39;of SkeletonMapper.&#39;</span><span class="p">)</span>
        <span class="c1"># init mapping parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detect_outlier</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_radius</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_neighbors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_rays</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_hull_vox</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_voting_neighbors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotation_method</span> <span class="o">=</span> <span class="s1">&#39;hull&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kd_radius</span> <span class="o">=</span> <span class="mi">1200</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresh</span> <span class="o">=</span> <span class="mf">2.2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_obj_voxel</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_min_votes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mitos&#39;</span><span class="p">:</span> <span class="mi">235</span><span class="p">,</span> <span class="s1">&#39;vc&#39;</span><span class="p">:</span> <span class="mi">191</span><span class="p">,</span> <span class="s1">&#39;sj&#39;</span><span class="p">:</span> <span class="mi">346</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sj&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;mitos&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;vc&#39;</span><span class="p">:</span> <span class="p">{}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># stores hull and radius estimation of each ray and node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hull_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hull_normals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skel_radius</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span><span class="p">,</span> <span class="s1">&#39;hull_coords&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hull_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span><span class="o">.</span><span class="n">hull_coords</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hull_normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span><span class="o">.</span><span class="n">hull_normals</span>
        <span class="c1"># init skeleton nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_property_features</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">property_feat_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anno</span><span class="o">.</span><span class="n">interpolate_nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">soma</span><span class="o">.</span><span class="n">getNodes</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">merge_soma_tracing</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_nodes</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cset</span> <span class="o">=</span> <span class="n">chunky</span><span class="o">.</span><span class="n">load_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cset_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cset</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hull_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scaled hull coordinates of skeleton membrane</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            Coordinate each hull point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hull_coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hull_sampling</span><span class="p">(</span><span class="n">thresh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thresh</span><span class="p">,</span>
                               <span class="n">detect_outlier</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">nb_rays</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">nb_neighbors</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">neighbor_radius</span><span class="o">=</span><span class="mi">220</span><span class="p">,</span>
                               <span class="n">max_dist_mult</span><span class="o">=</span><span class="mf">1.4</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hull_coords</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hull_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normal for each hull point pointing outwards</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            Normal vector of each hull point pointing outwards</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hull_normals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_coords</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_com</span><span class="p">)</span>
            <span class="n">skel_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">node_coords</span><span class="p">)</span>
            <span class="n">hull_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hull_coords</span>
            <span class="n">nearest_skel_nodes</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">skel_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">hull_coords</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">nearest_coords</span> <span class="o">=</span> <span class="n">node_coords</span><span class="p">[</span><span class="n">nearest_skel_nodes</span><span class="p">]</span>
            <span class="n">dir_vecs</span> <span class="o">=</span> <span class="n">hull_coords</span> <span class="o">-</span> <span class="n">nearest_coords</span>
            <span class="n">hull_normals</span> <span class="o">=</span> <span class="n">dir_vecs</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dir_vecs</span><span class="p">,</span>
                                                          <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">soma</span><span class="o">.</span><span class="n">getNodes</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">soma_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">soma</span><span class="o">.</span><span class="n">getNodes</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">soma_coords_pure</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">getCoordinate_scaled</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span>
                                            <span class="ow">in</span> <span class="n">soma_nodes</span><span class="p">])</span>
                    <span class="n">soma_node_ixs</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">skel_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">soma_coords_pure</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">com_soma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">soma_coords_pure</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">dist</span><span class="p">,</span> <span class="n">nn_ixs</span> <span class="o">=</span> <span class="n">skel_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">hull_coords</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nn_ixs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">soma_node_ixs</span><span class="p">:</span>
                            <span class="n">hull_normals</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">hull_coords</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_soma</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hull_normals</span> <span class="o">=</span> <span class="n">hull_normals</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hull_normals</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skel_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Radius of membrane at each skeleton node</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            cell radius at self.nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skel_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hull_sampling</span><span class="p">(</span><span class="n">thresh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thresh</span><span class="p">,</span>
                               <span class="n">detect_outlier</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">nb_rays</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">nb_neighbors</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">neighbor_radius</span><span class="o">=</span><span class="mi">220</span><span class="p">,</span>
                               <span class="n">max_dist_mult</span><span class="o">=</span><span class="mf">1.4</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skel_radius</span>

    <span class="k">def</span> <span class="nf">_create_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates sorted node list and corresponding ID- and coordinate-list.</span>
<span class="sd">        Enables fast access to node information in same ordering.</span>
<span class="sd">        Setter for node_com, node_ids and nodes attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">su</span><span class="o">.</span><span class="n">annotation_to_nx_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anno</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dfs_preorder_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">)):</span>
            <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">getCoordinate</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling</span><span class="p">)</span>
            <span class="n">ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
            <span class="c1"># contains mapped objects</span>
            <span class="n">node</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vc&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;mitos&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;sj&#39;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_com</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_ids</span> <span class="o">=</span> <span class="n">ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anno</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

<div class="viewcode-block" id="SkeletonMapper.merge_soma_tracing"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.SkeletonMapper.merge_soma_tracing">[docs]</a>    <span class="k">def</span> <span class="nf">merge_soma_tracing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># print &quot;Merging soma (%d nodes) with original annotation.&quot; % \</span>
        <span class="c1">#       (len(self.soma.getNodes()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">soma</span><span class="o">.</span><span class="n">interpolate_nodes</span><span class="p">(</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anno</span> <span class="o">=</span> <span class="n">su</span><span class="o">.</span><span class="n">merge_annotations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anno</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">soma</span><span class="p">)</span></div>

<div class="viewcode-block" id="SkeletonMapper.annotate_objects"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.SkeletonMapper.annotate_objects">[docs]</a>    <span class="k">def</span> <span class="nf">annotate_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1200</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;hull&#39;</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">2.2</span><span class="p">,</span>
                         <span class="n">filter_size</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">nb_neighbors</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                         <span class="n">nb_hull_vox</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">neighbor_radius</span><span class="o">=</span><span class="mi">220</span><span class="p">,</span>
                         <span class="n">detect_outlier</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nb_rays</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                         <span class="n">nb_voting_neighbors</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">max_dist_mult</span><span class="o">=</span><span class="mf">1.4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates self.object with annotated objects as UltrastructuralDataset,</span>
<span class="sd">        where object is in {mitos, vc, sj}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dh : DataHandler</span>
<span class="sd">            object containing SegmentationDataObjects mitos, vc, sj</span>
<span class="sd">        radius : int</span>
<span class="sd">            Radius in nm. Single integer if integer radius is for all</span>
<span class="sd">            objects the same. If list of three integer stick to ordering</span>
<span class="sd">            [mitos, vc, sj].</span>
<span class="sd">        method : str</span>
<span class="sd">            Either &#39;kd&#39; for fix radius or &#39;hull&#39;/&#39;supervoxel&#39; if</span>
<span class="sd">            membrane is available.</span>
<span class="sd">        thresh : float</span>
<span class="sd">            Denotes the factor which is multiplied with the maximum</span>
<span class="sd">            membrane probability. The resulting value is used as threshold after</span>
<span class="sd">            which the membrane is assumed to be existant.</span>
<span class="sd">        filter_size : int</span>
<span class="sd">            List of integer for each object [mitos, vc, sj]</span>
<span class="sd">        nb_neighbors : int</span>
<span class="sd">            minimum number of neighbors needed during</span>
<span class="sd">            outlier detection for a single hull point to survive.</span>
<span class="sd">        nb_hull_vox : int</span>
<span class="sd">            Number of object hull voxels which are used to</span>
<span class="sd">            estimate spatial proximity to skeleton (inside or outside).</span>
<span class="sd">        neighbor_radius : int</span>
<span class="sd">            Radius (nm) of ball in which to look for supporting</span>
<span class="sd">            hull voxels. Used during outlier detection.</span>
<span class="sd">        detect_outlier : bool</span>
<span class="sd">            use outlier-detection if True.</span>
<span class="sd">        nb_rays : int</span>
<span class="sd">            Number of rays send at each skeleton node</span>
<span class="sd">            (multiplied by a factor of 5). Defines the angle between two rays</span>
<span class="sd">            (=360 / nb_rays) in the orthogonal plane.</span>
<span class="sd">        nb_voting_neighbors : int</span>
<span class="sd">            Number votes of skeleton hull voxels (membrane</span>
<span class="sd">            representation) for object-mapping. Used for vc and mitos during</span>
<span class="sd">            geometrical position estimation of object nodes.</span>
<span class="sd">        max_dist_mult : float</span>
<span class="sd">            Multiplier for radius to estimate maximal distance of hull points</span>
<span class="sd">            to source node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">radius</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">radius</span><span class="p">):</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="p">[</span><span class="n">radius</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kd_radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kd_radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_size</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">filter_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotation_method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresh</span> <span class="o">=</span> <span class="n">thresh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detect_outlier</span> <span class="o">=</span> <span class="n">detect_outlier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_radius</span> <span class="o">=</span> <span class="n">neighbor_radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_neighbors</span> <span class="o">=</span> <span class="n">nb_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_rays</span> <span class="o">=</span> <span class="n">nb_rays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_hull_vox</span> <span class="o">=</span> <span class="n">nb_hull_vox</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_voting_neighbors</span> <span class="o">=</span> <span class="n">nb_voting_neighbors</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;hull&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hull_coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hull_sampling</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="n">nb_rays</span><span class="p">,</span> <span class="n">nb_neighbors</span><span class="p">,</span>
                               <span class="n">neighbor_radius</span><span class="p">,</span> <span class="n">detect_outlier</span><span class="p">,</span> <span class="n">max_dist_mult</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dh</span><span class="o">.</span><span class="n">mitos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># initialize segmentationDatasets for mapped objects</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mitos</span> <span class="o">=</span> <span class="n">UltrastructuralDataset</span><span class="p">(</span><span class="n">dh</span><span class="o">.</span><span class="n">mitos</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">dh</span><span class="o">.</span><span class="n">mitos</span><span class="o">.</span><span class="n">_rel_path_home</span><span class="p">,</span>
                                             <span class="n">dh</span><span class="o">.</span><span class="n">mitos</span><span class="o">.</span><span class="n">_path_to_chunk_dataset_head</span><span class="p">)</span>
            <span class="c1"># do the mapping</span>
            <span class="n">node_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_object</span><span class="p">(</span><span class="n">dh</span><span class="o">.</span><span class="n">mitos</span><span class="p">,</span> <span class="n">radius</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">method</span><span class="p">,</span> <span class="s2">&quot;mitos&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mitos</span><span class="o">.</span><span class="n">_node_ids</span> <span class="o">=</span> <span class="n">node_id2key</span><span class="p">(</span><span class="n">dh</span><span class="o">.</span><span class="n">mitos</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span> <span class="n">filter_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">nb_obj_found</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">element</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mitos</span><span class="o">.</span><span class="n">_node_ids</span> <span class="k">for</span>
                                    <span class="n">element</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]))</span>
            <span class="c1"># print &quot;[%s] Found %d %s using size filter %d&quot; % \</span>
            <span class="c1">#       (self.ix, nb_obj_found, &#39;mitos&#39;, filter_size[0])</span>
            <span class="c1"># store annotated segmentation objects</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)):</span>
                <span class="n">mito_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mitos</span><span class="o">.</span><span class="n">_node_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mito_keys</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="s1">&#39;mitos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="s1">&#39;mitos&#39;</span><span class="p">]</span>\
                                                     <span class="o">+</span> <span class="p">[</span><span class="n">dh</span><span class="o">.</span><span class="n">mitos</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mitos</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dh</span><span class="o">.</span><span class="n">mitos</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print &quot;Skipped mito-mapping.&quot;</span>
            <span class="k">pass</span>
        <span class="c1"># same for vc</span>
        <span class="k">if</span> <span class="n">dh</span><span class="o">.</span><span class="n">vc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vc</span> <span class="o">=</span> <span class="n">UltrastructuralDataset</span><span class="p">(</span><span class="n">dh</span><span class="o">.</span><span class="n">vc</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">dh</span><span class="o">.</span><span class="n">vc</span><span class="o">.</span><span class="n">_rel_path_home</span><span class="p">,</span>
                                          <span class="n">dh</span><span class="o">.</span><span class="n">vc</span><span class="o">.</span><span class="n">_path_to_chunk_dataset_head</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vc</span><span class="o">.</span><span class="n">_node_ids</span> <span class="o">=</span> <span class="n">node_id2key</span><span class="p">(</span><span class="n">dh</span><span class="o">.</span><span class="n">vc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_object</span><span class="p">(</span>
                <span class="n">dh</span><span class="o">.</span><span class="n">vc</span><span class="p">,</span> <span class="n">radius</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="p">,</span> <span class="s2">&quot;vc&quot;</span><span class="p">),</span> <span class="n">filter_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">nb_obj_found</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">element</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vc</span><span class="o">.</span><span class="n">_node_ids</span> <span class="k">for</span>
                                    <span class="n">element</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]))</span>
            <span class="c1"># print &quot;[%s] Found %d %s using size filter %d&quot; % \</span>
            <span class="c1">#       (self.ix, nb_obj_found, &#39;vc&#39;, filter_size[1])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)):</span>
                <span class="n">vc_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vc</span><span class="o">.</span><span class="n">_node_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vc_keys</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="s1">&#39;vc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="s1">&#39;vc&#39;</span><span class="p">]</span> <span class="o">+</span> \
                                                  <span class="p">[</span><span class="n">dh</span><span class="o">.</span><span class="n">vc</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vc</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dh</span><span class="o">.</span><span class="n">vc</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print &quot;Skipped vc-mapping.&quot;</span>
            <span class="k">pass</span>
        <span class="c1"># and sj</span>
        <span class="k">if</span> <span class="n">dh</span><span class="o">.</span><span class="n">sj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sj</span> <span class="o">=</span> <span class="n">UltrastructuralDataset</span><span class="p">(</span><span class="n">dh</span><span class="o">.</span><span class="n">sj</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">dh</span><span class="o">.</span><span class="n">sj</span><span class="o">.</span><span class="n">_rel_path_home</span><span class="p">,</span>
                                          <span class="n">dh</span><span class="o">.</span><span class="n">sj</span><span class="o">.</span><span class="n">_path_to_chunk_dataset_head</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sj</span><span class="o">.</span><span class="n">_node_ids</span> <span class="o">=</span> <span class="n">node_id2key</span><span class="p">(</span><span class="n">dh</span><span class="o">.</span><span class="n">sj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_object</span><span class="p">(</span>
                <span class="n">dh</span><span class="o">.</span><span class="n">sj</span><span class="p">,</span> <span class="n">radius</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">method</span><span class="p">,</span> <span class="s2">&quot;sj&quot;</span><span class="p">),</span> <span class="n">filter_size</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">nb_obj_found</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">element</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sj</span><span class="o">.</span><span class="n">_node_ids</span> <span class="k">for</span>
                                    <span class="n">element</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]))</span>
            <span class="c1"># print &quot;[%s] Found %d %s using size filter %d&quot; % \</span>
            <span class="c1">#       (self.ix, nb_obj_found, &#39;sj&#39;, filter_size[2])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)):</span>
                <span class="n">sj_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sj</span><span class="o">.</span><span class="n">_node_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sj_keys</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="s1">&#39;sj&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="s1">&#39;sj&#39;</span><span class="p">]</span> <span class="o">+</span> \
                                                  <span class="p">[</span><span class="n">dh</span><span class="o">.</span><span class="n">sj</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sj</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dh</span><span class="o">.</span><span class="n">sj</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print &quot;Skipped sj-mapping.&quot;</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_myelin_ds_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_myelinisation</span><span class="p">()</span></div>
        <span class="c1"># print &quot;--- Skeleton #%s fully annotated after %0.2f seconds with&quot; \</span>
        <span class="c1">#       &quot; &#39;%s&#39;-criterion&quot; % (self.ix, time.time() - start,</span>
        <span class="c1">#                            self.annotation_method)</span>

<div class="viewcode-block" id="SkeletonMapper.annotate_object"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.SkeletonMapper.annotate_object">[docs]</a>    <span class="k">def</span> <span class="nf">annotate_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">objtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Redirects mapping task to desired method-function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        objects: UltrastructuralDataset</span>
<span class="sd">        radius: int</span>
<span class="sd">            Radius of kd-tree in units of nm.</span>
<span class="sd">        method: str</span>
<span class="sd">            either &#39;hull&#39;, &#39;kd&#39; or &#39;supervoxel&#39;</span>
<span class="sd">        objtype : string</span>
<span class="sd">            characterising object type</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            mapped object ID&#39;s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;hull&#39;</span><span class="p">:</span>
            <span class="n">node_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_with_hull</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">objtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;supervoxel&#39;</span><span class="p">:</span>
            <span class="n">node_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_with_supervoxels</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">objtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gt_sampling&#39;</span><span class="p">:</span>
            <span class="n">node_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_with_kdtree_gt_sampling</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_with_kdtree</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_annotate_with_kdtree_gt_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Annotates objects to node if its representative coordinate (data) is</span>
<span class="sd">         within radius and samples dependent on the distance of each object</span>
<span class="sd">         such that the objecet distance distribution to its nearest node is</span>
<span class="sd">         nearly uniform (assume isotrope distribution at the beginning, i.e.</span>
<span class="sd">         ~ r**2).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : UltrastructuralDataset</span>
<span class="sd">            Dictionary of cell objects</span>
<span class="sd">        radius : int</span>
<span class="sd">            Cell radius at tracing nodes (in nm)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            annotated objects per node, i.e. list of lists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print &quot;Applying kd-tree with radius %s to %d nodes and %d objects&quot; % \</span>
        <span class="c1">#       (radius, len(self.node_com), len(data.rep_coords))</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">rep_coords</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="c1"># Get objects within constant radius for all nodes</span>
        <span class="k">assert</span> <span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Choose positive radius!&quot;</span>
        <span class="n">annotation_ids</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_com</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">annotation_ids</span><span class="p">):</span>
            <span class="n">node_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_com</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">dist_sub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">node_coord</span><span class="o">-</span><span class="n">coords</span><span class="p">[</span><span class="n">sublist</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist_sub</span><span class="p">)</span>
        <span class="n">nb_objects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">element</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">annotation_ids</span> <span class="k">for</span> <span class="n">element</span>
                                             <span class="ow">in</span> <span class="n">sublist</span><span class="p">]))</span>
        <span class="n">annotation_ids</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">element</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">annotation_ids</span> <span class="k">for</span> <span class="n">element</span>
                                                     <span class="ow">in</span> <span class="n">sublist</span><span class="p">])</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">element</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">dists</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">])</span>
        <span class="n">set_of_anno_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">annotation_ids</span><span class="p">))</span>
        <span class="c1"># print &quot;Found %d objects before sampling.&quot; % nb_objects</span>
        <span class="k">if</span> <span class="n">nb_objects</span> <span class="o">&lt;=</span> <span class="mi">400</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[]]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="n">set_of_anno_ids</span><span class="p">]</span>

        <span class="n">todo_list</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">list</span><span class="p">(</span><span class="n">set_of_anno_ids</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="bp">self</span><span class="o">.</span><span class="n">_nb_cpus</span><span class="p">]),</span>
                      <span class="n">annotation_ids</span><span class="p">,</span> <span class="n">dists</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nb_cpus</span><span class="p">)]</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nb_cpus</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">helper_samllest_dist</span><span class="p">,</span> <span class="n">todo_list</span><span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">final_ids</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">ix</span> <span class="k">for</span> <span class="n">sub_list</span> <span class="ow">in</span> <span class="n">res</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">sub_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">final_dists</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">dist</span> <span class="k">for</span> <span class="n">sub_list</span> <span class="ow">in</span> <span class="n">res</span> <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="n">sub_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">final_dists</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.95</span> <span class="o">*</span> <span class="n">max_dist</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">w_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">w_func</span><span class="p">(</span><span class="n">final_dists</span><span class="p">)</span>
        <span class="n">normalization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">/=</span> <span class="n">normalization</span>
        <span class="n">cum_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">sample_ixs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_ixs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">:</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">rand_nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># find first occurance of entry with higher value than random number</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cum_weights</span> <span class="o">&gt;</span> <span class="n">rand_nb</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">sample_ixs</span><span class="p">:</span>
                <span class="n">sample_ixs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">50000</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="p">[[]]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">final_ids</span><span class="p">[</span><span class="n">sample_ixs</span><span class="p">])]</span>

    <span class="k">def</span> <span class="nf">_annotate_with_kdtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Annotates objects to node if its representative coordinate (data) is</span>
<span class="sd">         within radius.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : UltrastructuralDataset</span>
<span class="sd">            Dictioanry of cell objects</span>
<span class="sd">        radius: int</span>
<span class="sd">            radii list (in nm)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of list of UltrastructuralDatasetObjects</span>
<span class="sd">            List with annotated objects per node, i.e. list of lists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print &quot;Applying kd-tree with radius %s to %d nodes and %d objects&quot; % \</span>
        <span class="c1">#       (radius, len(self.node_com), len(data.rep_coords))</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">rep_coords</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">annotation_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Get objects within constant radius for all nodes</span>
        <span class="k">assert</span> <span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Choose positive radius!&quot;</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_com</span><span class="p">:</span>
            <span class="n">annotation_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">radius</span><span class="p">))</span>
        <span class="n">nb_objects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">element</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">annotation_ids</span> <span class="k">for</span> <span class="n">element</span>
                                             <span class="ow">in</span> <span class="n">sublist</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">annotation_ids</span>

    <span class="k">def</span> <span class="nf">_annotate_with_supervoxels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">objtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Annotates objects to skeleton if sufficient randomly selected</span>
<span class="sd">        object hull voxels are within supervoxels of this skeleton.</span>
<span class="sd">        radius.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : UltrastructuralDataset</span>
<span class="sd">            Dictioanry of cell objects</span>
<span class="sd">        radius: int</span>
<span class="sd">            radii list (in nm)</span>
<span class="sd">        objtype : str</span>
<span class="sd">            Cell object type (sj, vc, mito)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of list of UltrastructuralDatasetObjects</span>
<span class="sd">            List with annotated objects per node, i.e. list of lists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_hull_vox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_hull_vox</span>
        <span class="n">red_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_with_kdtree</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">red_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">ix</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">red_ids</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]))</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ids</span><span class="p">)[</span><span class="n">red_ids</span><span class="p">]</span>
        <span class="n">curr_objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nb_cpus</span><span class="p">)</span>
        <span class="n">obj_voxel_coords</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">helper_get_voxels</span><span class="p">,</span> <span class="n">curr_objects</span><span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">cset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cset</span>
        <span class="n">obj_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rand_voxels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="n">curr_voxels</span> <span class="o">=</span> <span class="n">obj_voxel_coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">curr_obj_id</span> <span class="o">=</span> <span class="n">curr_objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">obj_id</span>
            <span class="n">rand_ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_voxels</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">nb_hull_vox</span><span class="p">)</span>
            <span class="n">rand_voxels</span> <span class="o">+=</span> <span class="n">curr_voxels</span><span class="p">[</span><span class="n">rand_ixs</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">obj_ids</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curr_obj_id</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb_hull_vox</span>
        <span class="n">mergelist_path</span> <span class="o">=</span> <span class="s1">&#39;/home/pschuber/data/gt/nml_obj/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="n">mapped_obj_ids</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">from_skeleton_to_mergelist</span><span class="p">(</span>
            <span class="n">cset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">anno</span><span class="p">,</span> <span class="s1">&#39;watershed_150_20_10_3_unique&#39;</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">,</span>
            <span class="n">rand_voxels</span><span class="p">,</span> <span class="n">obj_ids</span><span class="p">,</span> <span class="n">nb_processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nb_cpus</span><span class="p">,</span>
            <span class="n">mergelist_path</span><span class="o">=</span><span class="n">mergelist_path</span><span class="p">))</span>
        <span class="n">annotation_ids_new</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">min_votes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_min_votes</span><span class="p">[</span><span class="n">objtype</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">obj_voxel_coords</span><span class="p">)):</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">curr_objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">obj_id</span>
            <span class="n">inside_votes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mapped_obj_ids</span><span class="p">[</span><span class="n">mapped_obj_ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">ix</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">inside_votes</span> <span class="o">&gt;=</span> <span class="n">min_votes</span><span class="p">:</span>
                <span class="n">annotation_ids_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">red_ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapping_info</span><span class="p">[</span><span class="n">objtype</span><span class="p">][</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">inside_votes</span>
        <span class="k">return</span> <span class="p">[[]]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">annotation_ids_new</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_annotate_with_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">objtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates a membrane representation via ray-castings. Each ray ends as</span>
<span class="sd">        a point after reaching a certain threshold. The resulting point cloud</span>
<span class="sd">        is used to determine in- and outlier coordinates of object hull voxels.</span>
<span class="sd">        If sufficient voxels are inside the cloud, the corresponding object</span>
<span class="sd">        is mapped to the skeleton.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : UltrastructuralDataset</span>
<span class="sd">            Dictioanry of cell objects</span>
<span class="sd">        radius: int</span>
<span class="sd">            radii list (in nm)</span>
<span class="sd">        objtype : str</span>
<span class="sd">            Cell object type (sj, vc, mito)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of list of UltrastructuralDatasetObjects</span>
<span class="sd">            List with annotated objects per node, i.e. list of lists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sjtrue</span> <span class="o">=</span> <span class="p">(</span><span class="n">objtype</span> <span class="o">==</span> <span class="s1">&#39;sj&#39;</span><span class="p">)</span>
        <span class="n">max_sj_dist</span> <span class="o">=</span> <span class="mf">125.</span>
        <span class="n">nb_voting_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_voting_neighbors</span>
        <span class="n">nb_hull_vox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_hull_vox</span>
        <span class="c1"># print &quot;Annotating with hull criterion. Using %d voting neighbors and&quot; \</span>
        <span class="c1">#       &quot; %d hull voxel.&quot; % (nb_voting_neighbors, nb_hull_vox)</span>
        <span class="n">red_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_with_kdtree</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>
        <span class="n">red_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="nb">id</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">red_ids</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]))</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hull_coords</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">check_hull_normals</span><span class="p">(</span><span class="n">obj_coord</span><span class="p">,</span> <span class="n">hull_coords</span><span class="p">,</span> <span class="n">dir_vecs</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sjtrue</span><span class="p">:</span>
                <span class="n">obj_coord</span> <span class="o">=</span> <span class="n">obj_coord</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">left_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">obj_coord</span><span class="p">,</span> <span class="n">dir_vecs</span><span class="p">)</span>
                <span class="n">right_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dir_vecs</span> <span class="o">*</span> <span class="n">hull_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">left_side</span> <span class="o">-</span> <span class="n">right_side</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sign</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_hullnodes_dists</span><span class="p">,</span> <span class="n">n_hullnodes_ids</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">obj_coord</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
                <span class="n">mean_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">n_hullnodes_dists</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mean_dists</span> <span class="o">&lt;</span> <span class="n">max_sj_dist</span>

        <span class="c1"># here annotation_ids_new contains only one node.</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ids</span><span class="p">)[</span><span class="n">red_ids</span><span class="p">]</span>
        <span class="n">curr_objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
        <span class="n">nb_cpus</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">nb_cpus</span><span class="p">)</span>
        <span class="n">curr_object_voxels</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">helper_get_voxels</span><span class="p">,</span> <span class="n">curr_objects</span><span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">annotation_ids_new</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">min_votes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_min_votes</span><span class="p">[</span><span class="n">objtype</span><span class="p">]</span>
        <span class="c1"># print &quot;Mapping objects &#39;%s&#39; using %d min. votes while asking %s obj. &quot; \</span>
        <span class="c1">#       &quot;hull voxel and using %d skeleton hull voxel to decide if in or&quot; \</span>
        <span class="c1">#       &quot; out.&quot; % (objtype, min_votes, nb_hull_vox, nb_voting_neighbors)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_object_voxels</span><span class="p">)):</span>
            <span class="n">curr_obj_id</span> <span class="o">=</span> <span class="n">curr_objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">obj_id</span>
            <span class="n">curr_voxels</span> <span class="o">=</span> <span class="n">curr_object_voxels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rand_ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_voxels</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">nb_hull_vox</span><span class="p">)</span>
            <span class="n">rand_voxels</span> <span class="o">=</span> <span class="n">curr_voxels</span><span class="p">[</span><span class="n">rand_ixs</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">skel_hull_ixs</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">rand_voxels</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">nb_voting_neighbors</span><span class="p">)</span>
            <span class="n">is_in_hull</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">voxel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rand_voxels</span><span class="p">):</span>
                <span class="n">vx_near_cellixs</span> <span class="o">=</span> <span class="n">skel_hull_ixs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="n">is_in_hull</span> <span class="o">+=</span> <span class="n">check_hull_normals</span><span class="p">(</span><span class="n">voxel</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="n">vx_near_cellixs</span><span class="p">],</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">hull_normals</span><span class="p">[</span><span class="n">vx_near_cellixs</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">is_in_hull</span> <span class="o">&gt;=</span> <span class="n">min_votes</span><span class="p">:</span>
                <span class="n">annotation_ids_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">red_ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapping_info</span><span class="p">[</span><span class="n">objtype</span><span class="p">][</span><span class="n">curr_obj_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_in_hull</span>
        <span class="k">return</span> <span class="p">[[]]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="n">annotation_ids_new</span><span class="p">]</span>

<div class="viewcode-block" id="SkeletonMapper.hull_sampling"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.SkeletonMapper.hull_sampling">[docs]</a>    <span class="k">def</span> <span class="nf">hull_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">2.2</span><span class="p">,</span> <span class="n">nb_rays</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">nb_neighbors</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                      <span class="n">neighbor_radius</span><span class="o">=</span><span class="mi">220</span><span class="p">,</span> <span class="n">detect_outlier</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">max_dist_mult</span><span class="o">=</span><span class="mf">1.4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculates hull of tracing</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        thresh : float</span>
<span class="sd">            factor of maximum occurring prediction value</span>
<span class="sd">            after which membrane is triggered active.</span>
<span class="sd">        nb_rays : int</span>
<span class="sd">            Number of rays send at each skeleton node</span>
<span class="sd">            (multiplied by a factor of 5). Defines the angle between two rays</span>
<span class="sd">            (=360 / nb_rays) in the orthogonal plane.</span>
<span class="sd">        nb_neighbors : int</span>
<span class="sd">            minimum number of neighbors needed during</span>
<span class="sd">            outlier detection for a single hull point to survive.</span>
<span class="sd">        neighbor_radius : int</span>
<span class="sd">            Radius of ball in which to look for supporting</span>
<span class="sd">            hull voxels. Used during outlier detection.</span>
<span class="sd">        detect_outlier : bool</span>
<span class="sd">            use outlier-detection if True.</span>
<span class="sd">        max_dist_mult : float</span>
<span class="sd">            Multiplier for radius to generate maximal distance of hull points</span>
<span class="sd">            to source node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            Average radius per node in (9,9,20) corrected units estimated by</span>
<span class="sd">            rays propagated through Membrane prediction until threshold reached.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print &quot;Creating hull using scaling %s and threshold %0.2f with&quot; \</span>
        <span class="c1">#       &quot; outlier-detetion=%s&quot; % (self.scaling, thresh*255.0,</span>
        <span class="c1">#                                 str(detect_outlier))</span>
        <span class="n">mem_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mem_path</span>
        <span class="k">assert</span> <span class="n">mem_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Path to barrier must be given!&quot;</span>
        <span class="n">kd</span> <span class="o">=</span> <span class="n">KnossosDataset</span><span class="p">()</span>
        <span class="n">kd</span><span class="o">.</span><span class="n">initialize_from_knossos_path</span><span class="p">(</span><span class="n">mem_path</span><span class="p">)</span>
        <span class="n">used_node_ix</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mem_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">mem_shape</span> <span class="o">=</span> <span class="n">kd</span><span class="o">.</span><span class="n">boundary</span>
        <span class="c1"># compute orthogonal plane to linear interpolated skeleton at each com</span>
        <span class="n">orth_plane</span><span class="p">,</span> <span class="n">skel_interp</span> <span class="o">=</span> <span class="n">get_orth_plane</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_com</span><span class="p">)</span>
        <span class="c1"># test and rewrite node positions of skeleton_data</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">com</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_com</span><span class="p">):</span>
            <span class="n">com</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">com</span><span class="p">)</span> <span class="o">-</span> <span class="n">mem_pos</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span>
            <span class="n">smaller_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">com</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">out_of_mem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">com</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mem_shape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">smaller_zero</span> <span class="ow">or</span> <span class="n">out_of_mem</span><span class="p">:</span>
                <span class="n">coms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">com</span><span class="p">)</span>
                <span class="n">used_node_ix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">used_node_ix</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">used_node_ix</span><span class="p">)</span>
        <span class="n">coms</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">coms</span><span class="p">)</span>
        <span class="n">nb_nodes2proc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coms</span><span class="p">)</span>
        <span class="c1"># print &quot;Computing radii and point cloud for %d of %d nodes.&quot; % \</span>
        <span class="c1">#       (nb_nodes2proc, len(self.node_com))</span>
        <span class="c1"># print &quot;Total bounding box from %s to %s&quot; % (str(np.min(coms, axis=0)),</span>
        <span class="c1">#                                             str(np.max(coms, axis=0)))</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orth_plane</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">skel_interp</span><span class="p">))</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">skel_interp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">coms</span><span class="p">))</span>
        <span class="c1"># Find necessary bounding boxes containing nodes and index to get</span>
        <span class="c1"># corresponding orth. plane and interp.</span>
        <span class="n">boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">box</span> <span class="o">=</span> <span class="p">[</span><span class="n">coms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">node_attr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">used_node_ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># check if current node is end node</span>
        <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
        <span class="n">nb_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anno</span><span class="o">.</span><span class="n">getNodeReverseEdges</span><span class="p">(</span><span class="n">current_node</span><span class="p">))</span> <span class="o">+</span> \
                   <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anno</span><span class="o">.</span><span class="n">getNodeEdges</span><span class="p">(</span><span class="n">current_node</span><span class="p">))</span>
        <span class="c1"># store properties of nodes</span>
        <span class="n">node_attr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">skel_interp</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">orth_plane</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nb_edges</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coms</span><span class="p">)):</span>
            <span class="n">node_box_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">box</span><span class="o">+</span><span class="p">[</span><span class="n">coms</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">node_box_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">box</span><span class="o">+</span><span class="p">[</span><span class="n">coms</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">node_box_max</span> <span class="o">-</span> <span class="n">node_box_min</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vol</span> <span class="o">&gt;</span> <span class="mf">0.5e7</span><span class="p">:</span>
                <span class="n">boxes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">arr</span><span class="p">(</span><span class="n">box</span><span class="p">),</span> <span class="n">node_attr</span><span class="p">))</span>
                <span class="n">box</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">node_attr</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">box</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">used_node_ix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
            <span class="n">nb_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anno</span><span class="o">.</span><span class="n">getNodeReverseEdges</span><span class="p">(</span><span class="n">current_node</span><span class="p">))</span> <span class="o">+</span> \
                       <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anno</span><span class="o">.</span><span class="n">getNodeEdges</span><span class="p">(</span><span class="n">current_node</span><span class="p">))</span>
            <span class="n">node_attr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">skel_interp</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">orth_plane</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nb_edges</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">boxes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">arr</span><span class="p">(</span><span class="n">box</span><span class="p">),</span> <span class="n">node_attr</span><span class="p">))</span>
        <span class="c1"># print &quot;Found %d different boxes.&quot; % len(boxes)</span>
        <span class="c1"># print &quot;Using %d cpus.&quot; % self._nb_cpus</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nb_cpus</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map_async</span><span class="p">(</span><span class="n">get_radii_hull</span><span class="p">,</span> <span class="p">[(</span><span class="n">box</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span><span class="p">,</span>
                                <span class="n">mem_path</span><span class="p">,</span> <span class="n">nb_rays</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">max_dist_mult</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="n">boxes</span><span class="p">])</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="c1"># print &quot;\nFinished radius estimation and hull representation.&quot;</span>
        <span class="n">ixs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hull_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
            <span class="n">radii</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ixs</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">hull_list</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">vals</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="c1"># sort to match self.node_ids ordering</span>
        <span class="n">ixs</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">ixs</span><span class="p">)</span>
        <span class="n">ixs_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ixs</span><span class="p">)</span>
        <span class="n">radii_sorted</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">radii</span><span class="p">)[</span><span class="n">ixs_sorted</span><span class="p">]</span>
        <span class="c1"># check result</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ixs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_com</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Tracing nodes during hull mapping missing!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ixs</span><span class="p">[</span><span class="n">ixs_sorted</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_com</span><span class="p">)))</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Original tracing node indices differ from &quot;</span>
                               <span class="s2">&quot;returned indices in membrane radius result.&quot;</span><span class="p">)</span>
        <span class="n">coord_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">node</span><span class="o">.</span><span class="n">setDataElem</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="n">radii_sorted</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">coord_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">getCoordinate</span><span class="p">())</span>
            <span class="n">node</span><span class="o">.</span><span class="n">ID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
        <span class="n">big_skel_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">coord_list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span><span class="o">.</span><span class="n">getNodes</span><span class="p">():</span>
            <span class="n">ix_node</span> <span class="o">=</span> <span class="n">big_skel_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">getCoordinate</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">node</span><span class="o">.</span><span class="n">setDataElem</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">radii_sorted</span><span class="p">[</span><span class="n">ix_node</span><span class="p">],</span> <span class="mf">1.</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anno</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hull_coords</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">pt</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">hull_list</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">sub</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">hull_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">hull_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">hull_coords</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">detect_outlier</span><span class="p">:</span>
            <span class="n">hull_coords_ix</span> <span class="o">=</span> <span class="n">outlier_detection</span><span class="p">(</span><span class="n">hull_coords</span><span class="p">,</span> <span class="n">nb_neighbors</span><span class="p">,</span>
                                               <span class="n">neighbor_radius</span><span class="p">)</span>
            <span class="n">hull_coords</span> <span class="o">=</span> <span class="n">hull_coords</span><span class="p">[</span><span class="n">hull_coords_ix</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hull_coords</span> <span class="o">=</span> <span class="n">hull_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skel_radius</span> <span class="o">=</span> <span class="n">radii_sorted</span></div>

<div class="viewcode-block" id="SkeletonMapper.calc_myelinisation"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.SkeletonMapper.calc_myelinisation">[docs]</a>    <span class="k">def</span> <span class="nf">calc_myelinisation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates myelinisation at each node and writes it to</span>
<span class="sd">        node.data[&quot;myelin_pred&quot;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_myelin_ds_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Myelin dataset not found.&quot;</span>
        <span class="n">test_box</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">true_thresh</span> <span class="o">=</span> <span class="mf">100.</span>
        <span class="n">j0126_myelin_inside_ds</span> <span class="o">=</span> <span class="n">KnossosDataset</span><span class="p">()</span>
        <span class="n">j0126_myelin_inside_ds</span><span class="o">.</span><span class="n">initialize_from_knossos_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_myelin_ds_path</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span><span class="o">.</span><span class="n">getNodes</span><span class="p">():</span>
            <span class="n">myelin_b</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
            <span class="n">test_vol</span> <span class="o">=</span> <span class="n">j0126_myelin_inside_ds</span><span class="o">.</span><span class="n">from_raw_cubes_to_matrix</span><span class="p">(</span><span class="n">test_box</span><span class="p">,</span>
                                    <span class="n">n</span><span class="o">.</span><span class="n">getCoordinate</span><span class="p">(),</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">test_vol</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">true_thresh</span><span class="p">:</span>
                <span class="n">myelin_b</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
                <span class="n">n</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;myelin_pred&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;myelin_pred&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">node_comment</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">getComment</span><span class="p">()</span>
            <span class="n">ax_ix</span> <span class="o">=</span> <span class="n">node_comment</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;myelin&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ax_ix</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">appendComment</span><span class="p">(</span><span class="s1">&#39;myelin&#39;</span><span class="o">+</span><span class="n">myelin_b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">help_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_comment</span><span class="p">)</span>
                <span class="n">help_list</span><span class="p">[</span><span class="n">ax_ix</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">myelin_b</span>
                <span class="n">n</span><span class="o">.</span><span class="n">setComment</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">help_list</span><span class="p">))</span>
        <span class="n">majority_vote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span><span class="p">,</span> <span class="nb">property</span><span class="o">=</span><span class="s1">&#39;myelin&#39;</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">property_features</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Getter of property features, calculates axoness/spiness features</span>
<span class="sd">        if necessary</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array, bool</span>
<span class="sd">            property features, if spiness feature are given</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_property_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_property_features</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_feat_names</span><span class="p">,</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">spiness_given</span> <span class="o">=</span> <span class="n">calc_prop_feat_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">context_range</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_property_features</span>

<div class="viewcode-block" id="SkeletonMapper.predict_property"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.SkeletonMapper.predict_property">[docs]</a>    <span class="k">def</span> <span class="nf">predict_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rf</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">max_neck2endpoint_dist</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
                         <span class="n">max_head2endpoint_dist</span><span class="o">=</span><span class="mi">600</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predict property (axoness, spiness) of tracings</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rf: RandomForestClassifier</span>
<span class="sd">        prop: str</span>
<span class="sd">            property name</span>
<span class="sd">        max_neck2endpoint_dist: int</span>
<span class="sd">        max_head2endpoint_dist: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">property_feature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_features</span><span class="p">[</span><span class="n">prop</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">prop</span> <span class="o">==</span> <span class="s1">&#39;axoness&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spiness_given</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Spiness feature were not given &quot;</span>
                               <span class="s2">&quot;during axoness prediction!&quot;</span><span class="p">)</span>
        <span class="c1"># print &quot;Predicting %s using %d features.&quot; % \</span>
        <span class="c1">#       (prop, property_feature.shape[1])</span>
        <span class="n">proba</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">property_feature</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">property_feature</span><span class="p">)</span>
        <span class="n">node_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_features</span><span class="p">[</span><span class="n">prop</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_ids</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span><span class="o">.</span><span class="n">getNodeByID</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prop</span> <span class="o">==</span> <span class="s1">&#39;spiness&#39;</span> <span class="ow">and</span> <span class="s1">&#39;axoness_pred&#39;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;axoness_pred&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="n">node_comment</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">getComment</span><span class="p">()</span>
            <span class="n">ax_ix</span> <span class="o">=</span> <span class="n">node_comment</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span>
            <span class="n">node_pred</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pred</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ax_ix</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">appendComment</span><span class="p">(</span><span class="n">prop</span><span class="o">+</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">node_pred</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">help_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_comment</span><span class="p">)</span>
                <span class="n">help_list</span><span class="p">[</span><span class="n">ax_ix</span><span class="o">+</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_pred</span><span class="p">)</span>
                <span class="n">node</span><span class="o">.</span><span class="n">setComment</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">help_list</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">proba</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">setDataElem</span><span class="p">(</span><span class="n">prop</span><span class="o">+</span><span class="s1">&#39;_proba</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">ii</span><span class="p">,</span> <span class="n">proba</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ii</span><span class="p">])</span>
            <span class="n">node</span><span class="o">.</span><span class="n">setDataElem</span><span class="p">(</span><span class="n">prop</span><span class="o">+</span><span class="s1">&#39;_pred&#39;</span><span class="p">,</span> <span class="n">node_pred</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">setDataElem</span><span class="p">(</span><span class="s1">&#39;branch_dist&#39;</span><span class="p">,</span> <span class="n">property_feature</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">node</span><span class="o">.</span><span class="n">setDataElem</span><span class="p">(</span><span class="s1">&#39;end_dist&#39;</span><span class="p">,</span> <span class="n">property_feature</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># if prop == &#39;axoness&#39;:</span>
        <span class="c1">#     majority_vote(self.old_anno, &#39;axoness&#39;, 25000)</span>
        <span class="c1">#     pass</span>
        <span class="k">if</span> <span class="n">prop</span> <span class="o">==</span> <span class="s1">&#39;spiness&#39;</span><span class="p">:</span>
            <span class="n">assign_neck</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span><span class="p">,</span>
                        <span class="n">max_head2endpoint_dist</span><span class="o">=</span><span class="n">max_head2endpoint_dist</span><span class="p">,</span>
                        <span class="n">max_neck2endpoint_dist</span><span class="o">=</span><span class="n">max_neck2endpoint_dist</span><span class="p">)</span></div>

<div class="viewcode-block" id="SkeletonMapper.write2pkl"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.SkeletonMapper.write2pkl">[docs]</a>    <span class="k">def</span> <span class="nf">write2pkl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Writes MappedSkeleton object to .pkl file. Path is extracted from</span>
<span class="sd">        dh._datapath and MappedSkeleton ID.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            Path to kzip destination</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">copyfile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_old.pkl&#39;</span><span class="p">)</span>
            <span class="c1"># print &quot;.pkl file already existed, moved old one to %s.&quot; %\</span>
            <span class="c1">#       (path[:-4]+&#39;_old.pkl&#39;)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
           <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>
           <span class="c1"># print &quot;Skeleton %s saved successfully at %s.&quot; % (self.ix, path)</span>

<div class="viewcode-block" id="SkeletonMapper.write2kzip"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.SkeletonMapper.write2kzip">[docs]</a>    <span class="k">def</span> <span class="nf">write2kzip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Writes interpolated skeleton (and annotated objects) to nml at path.</span>
<span class="sd">        If self.write_obj_voxel flag is True a .txt file containing all object</span>
<span class="sd">        voxel with id is written in k.zip</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            Path to kzip destination</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">object_skel</span> <span class="o">=</span> <span class="n">Skeleton</span><span class="p">()</span>
        <span class="n">obj_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;mitos&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;vc&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;sj&#39;</span><span class="p">}</span>
        <span class="n">re_process_skels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># store path to written files for kzip compression</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># print &#39;Writing kzip to %s. Writing object voxels=%s&#39; \</span>
        <span class="c1">#       % (path, str(self.write_obj_voxel))</span>
        <span class="k">if</span> <span class="s1">&#39;.k.zip&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;nml&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;.zip&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;nml&#39;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">objects</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mitos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sj</span><span class="p">]):</span>
            <span class="n">object_annotation</span> <span class="o">=</span> <span class="n">SkeletonAnnotation</span><span class="p">()</span>
            <span class="n">object_annotation</span><span class="o">.</span><span class="n">scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span>
            <span class="n">object_annotation</span><span class="o">.</span><span class="n">appendComment</span><span class="p">(</span><span class="n">obj_dict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">objects</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">object_voxel</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">object_voxel_id</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">arr</span><span class="p">(</span><span class="n">objects</span><span class="o">.</span><span class="n">sizes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_size</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                <span class="nb">print</span> <span class="s2">&quot;Size filter does not work properly!&quot;</span>
                <span class="n">re_process_skels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="p">(</span><span class="n">objects</span><span class="o">.</span><span class="n">object_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">objects</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">curr_obj_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">obj_id</span><span class="p">)</span>
                <span class="n">map_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping_info</span><span class="p">[</span><span class="n">obj_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]][</span><span class="n">curr_obj_id</span><span class="p">]</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">SkeletonNode</span><span class="p">()</span><span class="o">.</span><span class="n">from_scratch</span><span class="p">(</span>
                    <span class="n">object_annotation</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">rep_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">obj</span><span class="o">.</span><span class="n">rep_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">rep_coord</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="mf">4.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">))</span>
                <span class="n">node</span><span class="o">.</span><span class="n">setPureComment</span><span class="p">(</span><span class="n">obj_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_obj_id</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_mi&#39;</span><span class="o">+</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">map_info</span><span class="p">))</span>
                <span class="n">object_annotation</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_obj_voxel</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">coords_to_add</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">hull_voxels</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IOError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                        <span class="c1"># print &quot;Could not find hull vx of object %s&quot; % str(key)</span>
                        <span class="c1"># print e</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Could not find hull voxel. &quot;</span>
                                      <span class="s2">&quot;Aborting </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">path</span><span class="p">,</span>
                                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">object_voxel</span> <span class="o">+=</span> <span class="n">coords_to_add</span>
                    <span class="n">object_voxel_id</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">obj_id</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_to_add</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_obj_voxel</span><span class="p">:</span>
                <span class="n">obj_hull_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">obj_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.txt&#39;</span>
                <span class="n">obj_hull2text</span><span class="p">(</span><span class="n">arr</span><span class="p">(</span><span class="n">object_voxel_id</span><span class="p">),</span> <span class="n">arr</span><span class="p">(</span><span class="n">object_voxel</span><span class="p">),</span> <span class="n">obj_hull_path</span><span class="p">)</span>
                <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_hull_path</span><span class="p">)</span>
                <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_hull_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_id.txt&#39;</span><span class="p">)</span>
            <span class="n">obj_pkl_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">obj_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.pkl&#39;</span>
            <span class="n">write_obj2pkl</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">obj_pkl_path</span><span class="p">)</span>
            <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_pkl_path</span><span class="p">)</span>
            <span class="n">object_skel</span><span class="o">.</span><span class="n">add_annotation</span><span class="p">(</span><span class="n">object_annotation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span><span class="o">.</span><span class="n">setComment</span><span class="p">(</span><span class="s2">&quot;skeleton&quot;</span><span class="p">)</span>
        <span class="n">object_skel</span><span class="o">.</span><span class="n">add_annotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">old_anno</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">soma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">object_skel</span><span class="o">.</span><span class="n">add_annotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">soma</span><span class="p">)</span>
        <span class="n">object_skel</span><span class="o">.</span><span class="n">toNml</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hull_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hull_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;xyz&#39;</span>
            <span class="n">hull2text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hull_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hull_normals</span><span class="p">,</span> <span class="n">hull_path</span><span class="p">)</span>
            <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hull_path</span><span class="p">)</span>
        <span class="n">kzip_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;k.zip&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">prop</span><span class="p">,</span> <span class="n">prop_feat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_features</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">feat_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">%s</span><span class="s1">_feat.csv&#39;</span> <span class="o">%</span> <span class="n">prop</span>
                <span class="n">write_feat2csv</span><span class="p">(</span><span class="n">feat_path</span><span class="p">,</span> <span class="n">prop_feat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_feat_names</span><span class="p">[</span><span class="n">prop</span><span class="p">])</span>
                <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feat_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">for</span> <span class="n">path_to_file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="n">write_data2kzip</span><span class="p">(</span><span class="n">kzip_path</span><span class="p">,</span> <span class="n">path_to_file</span><span class="p">)</span></div>
        <span class="c1"># print &quot;Mapped skeleton %s saved successfully at %s.&quot; % (self.ix,</span>
        <span class="c1">#                                                         kzip_path)</span>

<div class="viewcode-block" id="SkeletonMapper.get_plot_obj"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.SkeletonMapper.get_plot_obj">[docs]</a>    <span class="k">def</span> <span class="nf">get_plot_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts coordinates from annotated SegmentationObjects</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            object-voxels for each object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotation_method</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Objects not initialized!&quot;</span>
        <span class="n">voxel_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">objects</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mitos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sj</span><span class="p">]:</span>
            <span class="n">voxel_list1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">objects</span><span class="o">.</span><span class="n">object_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">voxels</span> <span class="o">=</span> <span class="n">objects</span><span class="o">.</span><span class="n">object_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">voxels</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">voxels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">voxels</span> <span class="o">=</span> <span class="n">voxels</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">voxel_list1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">voxels</span><span class="p">)</span>
            <span class="n">voxel_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">voxel_list1</span><span class="p">)</span>
        <span class="n">mito</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">element</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">voxel_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">],</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">vc</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">element</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">voxel_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">],</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">sj</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">element</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">voxel_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">],</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mito</span><span class="p">,</span> <span class="n">vc</span><span class="p">,</span> <span class="n">sj</span></div></div>


<div class="viewcode-block" id="node_id2key"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.node_id2key">[docs]</a><span class="k">def</span> <span class="nf">node_id2key</span><span class="p">(</span><span class="n">segdataobject</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span> <span class="n">filter_size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps list indices in node_ids to keys of SegmentationObjects. Filters</span>
<span class="sd">    objects bigger than filter_size.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param segdataobject: UltrastructuralDataset of object type currently processed</span>
<span class="sd">    :param node_ids: List of list containing annotated object ids for each node</span>
<span class="sd">    :param filter_size: int minimum number of voxels of object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        objects keys</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">segdataobject</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">filter_size</span><span class="p">:</span>
                <span class="n">node</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">segdataobject</span><span class="o">.</span><span class="n">ids</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
                <span class="n">node</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">key</span>
    <span class="n">node_ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">node_ids</span></div>


<div class="viewcode-block" id="outlier_detection"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.outlier_detection">[docs]</a><span class="k">def</span> <span class="nf">outlier_detection</span><span class="p">(</span><span class="n">point_list</span><span class="p">,</span> <span class="n">min_num_neigh</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds hull outlier using point density criterion</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    point_list: list</span>
<span class="sd">        List of coordinates</span>
<span class="sd">    min_num_neigh: int</span>
<span class="sd">        Minimum number of neighbors, s.t. hull-point survives.</span>
<span class="sd">    radius: int</span>
<span class="sd">        Radius in nm to look for neighbors</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.array</span>
<span class="sd">        Cleaned point cloud</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">point_list</span><span class="p">),</span> <span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="c1"># print &quot;Starting outlier detection.&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point_list</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">point</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">point_list</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point_list</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">nb_points</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
    <span class="c1"># print &quot;Old #points:\t%d&quot; % nb_points</span>
    <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">num_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
        <span class="n">new_points</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_neighbors</span><span class="o">&gt;=</span><span class="n">min_num_neigh</span>
    <span class="c1"># print &quot;Found %d outlier.&quot; % np.sum(~new_points)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_points</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_radii_hull"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.get_radii_hull">[docs]</a><span class="k">def</span> <span class="nf">get_radii_hull</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ray_cast_avail</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;ray_casting_radius-module needed for this&quot;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Wrapper-function for point cloud extraction from membrane prediction.</span>
<span class="sd">    Gets a bounding box with nodes, loads the membrane prediction for these</span>
<span class="sd">    and then calculates the radius and hull at each skeleton node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># node attribute contains skel_interpolation, orthogonal plane and</span>
    <span class="c1"># bool if node is end node</span>
    <span class="n">box</span><span class="p">,</span> <span class="n">node_attr</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">scaling</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">mem_path</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">nb_rays</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">thresh_factor</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">max_dist_mult</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">kd</span> <span class="o">=</span> <span class="n">KnossosDataset</span><span class="p">()</span>
    <span class="n">kd</span><span class="o">.</span><span class="n">initialize_from_knossos_path</span><span class="p">(</span><span class="n">mem_path</span><span class="p">)</span>
    <span class="n">mem_shape</span> <span class="o">=</span> <span class="n">kd</span><span class="o">.</span><span class="n">boundary</span>
    <span class="n">ray_buffer</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">])</span><span class="o">/</span><span class="n">scaling</span>
    <span class="n">prop_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">ray_buffer</span><span class="p">,</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">prop_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">ray_buffer</span><span class="p">,</span> <span class="n">mem_shape</span><span class="p">],</span>
                       <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">prop_offset</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">prop_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="n">e9</span><span class="p">,</span> <span class="s2">&quot;Bounding box too big!&quot;</span>
    <span class="n">mem</span> <span class="o">=</span> <span class="n">kd</span><span class="o">.</span><span class="n">from_raw_cubes_to_matrix</span><span class="p">(</span><span class="n">prop_size</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                                      <span class="n">prop_offset</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                                      <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># thresholding membrane</span>
    <span class="n">mem</span><span class="p">[</span><span class="n">mem</span> <span class="o">&lt;=</span> <span class="mf">0.4</span><span class="o">*</span><span class="n">mem</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mem</span> <span class="o">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="n">thresh_factor</span>
    <span class="c1"># iterate over every node</span>
    <span class="n">avg_radius_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">val_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">todo_list</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">box</span><span class="p">),</span> <span class="p">[</span><span class="n">nb_rays</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">box</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_attr</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">todo_list</span><span class="p">:</span>
        <span class="n">radius</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">membrane_points</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">ray_casting_radius</span><span class="p">(</span>
            <span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">el</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">el</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">el</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">scaling</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">prop_offset</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">el</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">max_dist_mult</span><span class="p">)</span>
        <span class="n">all_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">(</span><span class="n">membrane_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">avg_radius_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
        <span class="n">ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
        <span class="n">val_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">mem</span>
    <span class="k">return</span> <span class="n">avg_radius_list</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">all_points</span><span class="p">,</span> <span class="n">val_list</span></div>


<div class="viewcode-block" id="read_pair_cs"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.read_pair_cs">[docs]</a><span class="k">def</span> <span class="nf">read_pair_cs</span><span class="p">(</span><span class="n">pair_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function to collect pairwise contact site information. Extracts</span>
<span class="sd">    axoness prediction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pair_path : str</span>
<span class="sd">        path to pairwise contact site kzip</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SkeletonAnnotation</span>
<span class="sd">        annotation object without contact site hull voxel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pairwise_anno</span> <span class="o">=</span> <span class="n">su</span><span class="o">.</span><span class="n">loadj0126NML</span><span class="p">(</span><span class="n">pair_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">predict_axoness_from_nodes</span><span class="p">(</span><span class="n">pairwise_anno</span><span class="p">)</span>
    <span class="n">new_anno</span> <span class="o">=</span> <span class="n">SkeletonAnnotation</span><span class="p">()</span>
    <span class="n">new_anno</span><span class="o">.</span><span class="n">setComment</span><span class="p">(</span><span class="n">pairwise_anno</span><span class="o">.</span><span class="n">getComment</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">pairwise_anno</span><span class="o">.</span><span class="n">getNodes</span><span class="p">()):</span>
        <span class="n">n_comment</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">getComment</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;_hull&#39;</span> <span class="ow">in</span> <span class="n">n_comment</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">new_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_anno</span></div>


<div class="viewcode-block" id="prepare_syns_btw_annos"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.prepare_syns_btw_annos">[docs]</a><span class="k">def</span> <span class="nf">prepare_syns_btw_annos</span><span class="p">(</span><span class="n">pairwise_paths</span><span class="p">,</span> <span class="n">dest_path</span><span class="p">,</span> <span class="n">max_hull_dist</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
                           <span class="n">concom_dist</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks pairwise for contact sites between annotation objects found at paths</span>
<span class="sd">    in nml_list. Adds sj, vc and nearest skeleton nodes to found contact sites.</span>
<span class="sd">    Writes &#39;contact_sites.nml&#39; to nml-path containing contact sites of all</span>
<span class="sd">    nml&#39;s.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pairwise_paths : list of str</span>
<span class="sd">        List of pairwise paths to nml&#39;s</span>
<span class="sd">    dest_path : str</span>
<span class="sd">        Path to directory where to store result of</span>
<span class="sd">     synapse mapping</span>
<span class="sd">    max_hull_dist : float</span>
<span class="sd">        maximum distance between skeletons in nm</span>
<span class="sd">    concom_dist : float</span>
<span class="sd">        Maximum distance of connected components (nm)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sname</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">sname</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;soma01&#39;</span><span class="p">,</span> <span class="s1">&#39;soma02&#39;</span><span class="p">,</span> <span class="s1">&#39;soma03&#39;</span><span class="p">,</span> <span class="s1">&#39;soma04&#39;</span><span class="p">,</span> <span class="s1">&#39;soma05&#39;</span><span class="p">]:</span>
        <span class="n">nb_cpus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nb_cpus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">max_hull_dist</span><span class="p">,</span> <span class="n">concom_dist</span><span class="p">,</span> <span class="n">dest_path</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
              <span class="ow">in</span> <span class="n">pairwise_paths</span><span class="p">]</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">start_multiprocess</span><span class="p">(</span><span class="n">syn_btw_anno_pair</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">nb_cpus</span><span class="o">=</span><span class="n">nb_cpus</span><span class="p">)</span></div>


<div class="viewcode-block" id="similarity_check"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.similarity_check">[docs]</a><span class="k">def</span> <span class="nf">similarity_check</span><span class="p">(</span><span class="n">skel_a</span><span class="p">,</span> <span class="n">skel_b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;If absolute number of identical nodes is bigger then certain threshold</span>
<span class="sd">    return similar.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    skel_a : SkeletonAnnotation</span>
<span class="sd">        Skeleton a</span>
<span class="sd">    skel_b: SkeletonAnnotation</span>
<span class="sd">        Skeleton b</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        skel_a and skel_b are similar</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a_coords</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">getCoordinate</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">skel_a</span><span class="o">.</span><span class="n">getNodes</span><span class="p">()])</span> <span class="o">*</span> \
               <span class="n">skel_a</span><span class="o">.</span><span class="n">scaling</span>
    <span class="n">a_coords_sample</span> <span class="o">=</span> <span class="n">a_coords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_coords</span><span class="p">),</span> <span class="mi">100</span><span class="p">)]</span>
    <span class="n">b_coords</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">getCoordinate</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">skel_b</span><span class="o">.</span><span class="n">getNodes</span><span class="p">()])</span> <span class="o">*</span> \
                <span class="n">skel_b</span><span class="o">.</span><span class="n">scaling</span>
    <span class="n">b_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">b_coords</span><span class="p">)</span>
    <span class="n">a_near</span> <span class="o">=</span> <span class="n">b_tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">a_coords_sample</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nb_equal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="nb">id</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">a_near</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">])</span>
    <span class="n">similar</span> <span class="o">=</span> <span class="n">nb_equal</span> <span class="o">&gt;</span> <span class="mi">10</span>
    <span class="k">return</span> <span class="n">similar</span></div>


<div class="viewcode-block" id="similarity_check_star"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.similarity_check_star">[docs]</a><span class="k">def</span> <span class="nf">similarity_check_star</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function&quot;&quot;&quot;</span>
    <span class="n">skel1</span> <span class="o">=</span> <span class="n">load_ordered_mapped_skeleton</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">skel2</span> <span class="o">=</span> <span class="n">load_ordered_mapped_skeleton</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">similar</span> <span class="o">=</span> <span class="n">similarity_check</span><span class="p">(</span><span class="n">skel1</span><span class="p">,</span> <span class="n">skel2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">similar</span><span class="p">,</span> <span class="n">params</span></div>


<div class="viewcode-block" id="syn_btw_anno_pair"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.syn_btw_anno_pair">[docs]</a><span class="k">def</span> <span class="nf">syn_btw_anno_pair</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get synapse information between two mapped annotation objects. Details are</span>
<span class="sd">    written to pairwise nml (all contact sites between pairs contained) and</span>
<span class="sd">    to nml for each contact site.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    params : list</span>
<span class="sd">        [path_a, path_b, max_hull_dist, concom_dist]</span>
<span class="sd">    path_a : str</span>
<span class="sd">        path to mapped annotation object</span>
<span class="sd">    path_b : str</span>
<span class="sd">        path to mapped annotation object</span>
<span class="sd">    max_hull_dist : float</span>
<span class="sd">        maximum distance between skeletons (nm)</span>
<span class="sd">    concom_dist : float</span>
<span class="sd">        maximum distance of connected components (nm)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path_a</span><span class="p">,</span> <span class="n">path_b</span><span class="p">,</span> <span class="n">max_hull_dist</span><span class="p">,</span> <span class="n">concom_dist</span><span class="p">,</span> <span class="n">dest_path</span> <span class="o">=</span> <span class="n">params</span>
    <span class="n">vx_overlap_dist</span> <span class="o">=</span> <span class="mi">80</span>
    <span class="n">max_vc_dist</span> <span class="o">=</span> <span class="mi">80</span>
    <span class="n">max_sj_dist</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="n">min_cs_area</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e6</span>
    <span class="c1"># try:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">load_anno_list</span><span class="p">([</span><span class="n">path_a</span><span class="p">],</span> <span class="n">load_mitos</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sj_dict</span> <span class="o">=</span> <span class="n">load_objpkl_from_kzip</span><span class="p">(</span><span class="n">path_a</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">object_dict</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">load_anno_list</span><span class="p">([</span><span class="n">path_b</span><span class="p">],</span> <span class="n">load_mitos</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">id2skel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span>\
        <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">sj_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">load_objpkl_from_kzip</span><span class="p">(</span><span class="n">path_b</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">object_dict</span><span class="p">)</span>
    <span class="n">scaling</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scaling</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">r&#39;iter_0_(\d+)&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">r&#39;iter_0_(\d+)&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">annotation_name</span> <span class="o">=</span> <span class="s1">&#39;skel_&#39;</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span>
    <span class="c1"># DO similarity check and skip combination if true</span>
    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="p">:</span>
        <span class="c1"># print &quot;\n Skipping nearly identical skeletons: %s and %s, &quot; \</span>
        <span class="c1">#       &quot;because of identical ID.\n &quot; % (a[0].filename, b[0].filename)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">similarity_check</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># print &quot;\n Skipping nearly identical skeletons: %s and %s, &quot; \</span>
        <span class="c1">#       &quot;because of similarity check.\n&quot; % (a[0].filename, b[0].filename)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">csites</span><span class="p">,</span> <span class="n">csite_ids</span> <span class="o">=</span> <span class="n">cs_btw_annos</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_hull_dist</span><span class="p">,</span> <span class="n">concom_dist</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">csites</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># save information about pairwise csites in one nml</span>
    <span class="n">pairwise_anno</span> <span class="o">=</span> <span class="n">SkeletonAnnotation</span><span class="p">()</span>
    <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">appendComment</span><span class="p">(</span><span class="n">annotation_name</span><span class="p">)</span>
    <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">scaling</span> <span class="o">=</span> <span class="n">scaling</span>

    <span class="c1"># get sj_objects with hull voxels if available</span>
    <span class="n">sj_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">getNodes</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">getNodes</span><span class="p">())</span>
    <span class="n">sj_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">sj_nodes</span><span class="p">:</span>
        <span class="n">global_sj_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;sj-(\d+)&#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">getComment</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">sj_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">global_sj_id</span><span class="p">)</span>
    <span class="n">sj_id_to_ix</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sj_ids</span><span class="p">):</span>
        <span class="n">sj_id_to_ix</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sj_hull_coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sj_hull_coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sj_hull_voxel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sj_hull_coords</span><span class="p">,</span>
                                        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sj_hull_coords</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sj_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sj_hull_ids</span><span class="p">,</span>
                                        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sj_hull_ids</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sj_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">sj_hull_voxel</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sj_tree</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># get vc_objects with hull voxels if available</span>
    <span class="n">vc_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">getNodes</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">getNodes</span><span class="p">())</span>
    <span class="n">vc_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">vc_nodes</span><span class="p">:</span>
        <span class="n">global_vc_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;vc-(\d+)&#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">getComment</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">vc_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">global_vc_id</span><span class="p">)</span>
    <span class="n">vc_id_to_ix</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vc_ids</span><span class="p">):</span>
        <span class="n">vc_id_to_ix</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vc_hull_coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vc_hull_coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">vc_hull_voxel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vc_hull_coords</span><span class="p">,</span>
                                        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vc_hull_coords</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">vc_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vc_hull_ids</span><span class="p">,</span>
                                        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vc_hull_ids</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">vc_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">vc_hull_voxel</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vc_tree</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># iterate over all contact sites between skeletons, calc skeleton</span>
    <span class="c1"># kd-tree in advance</span>
    <span class="n">a_skel_node_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getNodes</span><span class="p">()]</span>
    <span class="n">a_skel_node_coords</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">getCoordinate</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span>
                           <span class="n">a_skel_node_list</span><span class="p">])</span> <span class="o">*</span> <span class="n">arr</span><span class="p">(</span><span class="n">scaling</span><span class="p">)</span>
    <span class="n">a_skel_node_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">a_skel_node_coords</span><span class="p">)</span>
    <span class="n">b_skel_node_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getNodes</span><span class="p">()]</span>
    <span class="n">b_skel_node_coords</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">getCoordinate</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span>
                           <span class="n">b_skel_node_list</span><span class="p">])</span> <span class="o">*</span> <span class="n">arr</span><span class="p">(</span><span class="n">scaling</span><span class="p">)</span>
    <span class="n">b_skel_node_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">b_skel_node_coords</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">csite</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">csites</span><span class="p">):</span>
        <span class="n">vc_bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">sj_bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># save information about one contact site in extra nml dependent on</span>
        <span class="c1"># occuring vc and sj (four different categories)</span>
        <span class="n">contact_site_name</span> <span class="o">=</span> <span class="n">annotation_name</span><span class="o">+</span><span class="s1">&#39;_cs</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">contact_site_anno</span> <span class="o">=</span> <span class="n">SkeletonAnnotation</span><span class="p">()</span>
        <span class="n">contact_site_anno</span><span class="o">.</span><span class="n">scaling</span> <span class="o">=</span> <span class="n">scaling</span>
        <span class="n">curr_csite_ids</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">csite_ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">csite_name</span> <span class="o">=</span> <span class="s1">&#39;cs&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_&#39;</span>
        <span class="n">csite_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">csite</span><span class="p">)</span>

        <span class="c1"># get hull area</span>
        <span class="n">csb_area</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">csa_area</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">csb_points</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">csite</span><span class="p">)[</span><span class="n">curr_csite_ids</span><span class="p">]</span>
        <span class="n">csa_points</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">csite</span><span class="p">)[</span><span class="o">~</span><span class="n">curr_csite_ids</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">curr_csite_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">csb_area</span> <span class="o">=</span> <span class="n">convex_hull_area</span><span class="p">(</span><span class="n">csb_points</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># print e</span>
            <span class="c1"># print &quot;Could not calculate a_area!!!!&quot;</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">curr_csite_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">csa_area</span> <span class="o">=</span> <span class="n">convex_hull_area</span><span class="p">(</span><span class="n">csa_points</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># print e</span>
            <span class="c1"># print &quot;Could not calculate b_area!!!!&quot;</span>
            <span class="k">pass</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">csite</span><span class="p">):</span>
            <span class="n">coord_id</span> <span class="o">=</span> <span class="n">curr_csite_ids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">SkeletonNode</span><span class="p">()</span><span class="o">.</span><span class="n">from_scratch</span><span class="p">(</span>
                <span class="n">contact_site_anno</span><span class="p">,</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">scaling</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">scaling</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">scaling</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">node</span><span class="o">.</span><span class="n">setPureComment</span><span class="p">(</span><span class="n">csite_name</span> <span class="o">+</span> <span class="n">id2skel</span><span class="p">(</span><span class="n">coord_id</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_hull&#39;</span><span class="p">)</span>
            <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">mean_cs_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">csb_area</span><span class="p">,</span> <span class="n">csa_area</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">mean_cs_area</span> <span class="o">&lt;</span> <span class="n">min_cs_area</span><span class="p">:</span>
            <span class="c1"># print &quot;Skipping cs because of area:&quot;, mean_cs_area</span>
            <span class="k">continue</span>

        <span class="c1"># get hull distance</span>
        <span class="n">csa_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">csa_points</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ixs</span> <span class="o">=</span> <span class="n">csa_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">csb_points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cs_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="c1"># check vc and sj</span>
        <span class="k">if</span> <span class="n">sj_tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">near_sj_ixs</span> <span class="o">=</span> <span class="n">sj_tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">csite</span><span class="p">,</span> <span class="n">max_sj_dist</span><span class="p">)</span>
            <span class="n">near_sj_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">sj_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">near_sj_ixs</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                                    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">near_sj_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">abs_ol</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">overlap_cs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">overlap_area</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">overlap_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">sj_id</span> <span class="ow">in</span> <span class="n">near_sj_ids</span><span class="p">:</span>
            <span class="n">sj_ix</span> <span class="o">=</span> <span class="n">sj_id_to_ix</span><span class="p">[</span><span class="n">sj_id</span><span class="p">]</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sj_nodes</span><span class="p">[</span><span class="n">sj_ix</span><span class="p">])</span>
            <span class="n">curr_sj_voxel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sj_dict</span><span class="p">[</span><span class="n">sj_id</span><span class="p">]</span><span class="o">.</span><span class="n">voxels</span><span class="p">)</span> <span class="o">*</span> <span class="n">scaling</span>
            <span class="n">overlap_new</span><span class="p">,</span> <span class="n">overlap_cs_new</span><span class="p">,</span> <span class="n">overlap_area_new</span><span class="p">,</span>\
                <span class="n">center_coord_new</span><span class="p">,</span> <span class="n">overlap_coords_new</span> <span class="o">=</span> <span class="n">calc_overlap</span><span class="p">(</span>
                    <span class="n">csite</span><span class="p">,</span> <span class="n">curr_sj_voxel</span><span class="p">,</span> <span class="n">vx_overlap_dist</span><span class="p">)</span>
            <span class="n">abs_ol_new</span> <span class="o">=</span> <span class="n">overlap_new</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_sj_voxel</span><span class="p">)</span>
            <span class="n">old_comment</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">getComment</span><span class="p">()</span>
            <span class="n">node</span><span class="o">.</span><span class="n">setPureComment</span><span class="p">(</span><span class="n">csite_name</span> <span class="o">+</span> <span class="s1">&#39;relol</span><span class="si">%0.3f</span><span class="s1">_absol</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">overlap_new</span><span class="p">,</span> <span class="n">abs_ol_new</span><span class="p">)</span> <span class="o">+</span> <span class="n">old_comment</span><span class="p">)</span>
            <span class="n">contact_site_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overlap_new</span> <span class="o">&gt;</span> <span class="n">overlap</span><span class="p">:</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap_new</span>
                <span class="n">abs_ol</span> <span class="o">=</span> <span class="n">abs_ol_new</span>
                <span class="n">overlap_cs</span> <span class="o">=</span> <span class="n">overlap_cs_new</span>
                <span class="n">overlap_area</span> <span class="o">=</span> <span class="n">overlap_area_new</span>
                <span class="n">overlap_coords</span> <span class="o">=</span> <span class="n">overlap_coords_new</span>
        <span class="k">if</span> <span class="n">vc_tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">near_vc_ixs</span> <span class="o">=</span> <span class="n">vc_tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">csite</span><span class="p">,</span> <span class="n">max_vc_dist</span><span class="p">)</span>
            <span class="n">near_vc_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">vc_ids</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span>
                               <span class="n">near_vc_ixs</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">near_vc_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vc_id</span> <span class="ow">in</span> <span class="n">near_vc_ids</span><span class="p">:</span>
            <span class="n">vc_ix</span> <span class="o">=</span> <span class="n">vc_id_to_ix</span><span class="p">[</span><span class="n">vc_id</span><span class="p">]</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">vc_nodes</span><span class="p">[</span><span class="n">vc_ix</span><span class="p">])</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">nearest_ix</span> <span class="o">=</span> <span class="n">csite_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">getCoordinate</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">nearest_id</span> <span class="o">=</span> <span class="n">curr_csite_ids</span><span class="p">[</span><span class="n">nearest_ix</span><span class="p">]</span>
            <span class="n">old_comment</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">getComment</span><span class="p">()</span>
            <span class="n">node</span><span class="o">.</span><span class="n">setPureComment</span><span class="p">(</span><span class="n">csite_name</span> <span class="o">+</span> <span class="n">id2skel</span><span class="p">(</span><span class="n">nearest_id</span><span class="p">)</span> <span class="o">+</span>
                                <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">old_comment</span><span class="p">)</span>
            <span class="n">contact_site_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># get center node (representative cs coordinate)</span>
        <span class="n">cs_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">csite</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">csite</span><span class="p">))</span>
        <span class="n">cs_center_ix</span> <span class="o">=</span> <span class="n">csite_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">cs_center</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cs_center</span> <span class="o">=</span> <span class="n">csite</span><span class="p">[</span><span class="n">cs_center_ix</span><span class="p">]</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">SkeletonNode</span><span class="p">()</span><span class="o">.</span><span class="n">from_scratch</span><span class="p">(</span><span class="n">contact_site_anno</span><span class="p">,</span>
                                           <span class="n">cs_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">scaling</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                           <span class="n">cs_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">scaling</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                           <span class="n">cs_center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">scaling</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="n">csite_name</span><span class="o">+</span><span class="s1">&#39;area</span><span class="si">%0.2f</span><span class="s1">_dist</span><span class="si">%0.4f</span><span class="s1">_center&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mean_cs_area</span><span class="p">,</span>
                                                             <span class="n">cs_dist</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;adj_skel1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;adj_skel2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">near_vc_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vc_bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">comment</span> <span class="o">+=</span> <span class="s1">&#39;_vc&#39;</span>
            <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">setComment</span><span class="p">(</span><span class="n">annotation_name</span><span class="o">+</span><span class="s1">&#39;_syn_candidate&#39;</span><span class="p">)</span>
            <span class="n">contact_site_name</span> <span class="o">+=</span> <span class="s1">&#39;_vc&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">near_sj_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sj_bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">comment</span> <span class="o">+=</span> <span class="s1">&#39;_sj_relol</span><span class="si">%0.3f</span><span class="s1">_absol</span><span class="si">%d</span><span class="s1">_csrelol</span><span class="si">%0.3f</span><span class="s1">_areaol</span><span class="si">%0.3f</span><span class="s1">&#39;</span> <span class="o">%</span> \
                       <span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="n">abs_ol</span><span class="p">,</span> <span class="n">overlap_cs</span><span class="p">,</span> <span class="n">overlap_area</span><span class="p">)</span>
            <span class="n">contact_site_name</span> <span class="o">+=</span> <span class="s1">&#39;_sj&#39;</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_path</span> <span class="o">+</span> <span class="s1">&#39;/overlap_vx/&#39;</span> <span class="o">+</span> <span class="n">contact_site_name</span> <span class="o">+</span>
                    <span class="s1">&#39;ol_vx.npy&#39;</span><span class="p">,</span> <span class="n">overlap_coords</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;syn_feat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cs_dist</span><span class="p">,</span> <span class="n">mean_cs_area</span><span class="p">,</span> <span class="n">overlap_area</span><span class="p">,</span>
                                         <span class="n">overlap</span><span class="p">,</span> <span class="n">abs_ol</span><span class="p">,</span> <span class="n">overlap_cs</span><span class="p">])</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cs_dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs_dist</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;mean_cs_area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_cs_area</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;overlap_area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlap_area</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;overlap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlap</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;abs_ol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_ol</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;overlap_cs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlap_cs</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cs_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contact_site_name</span>
        <span class="n">node</span><span class="o">.</span><span class="n">setPureComment</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
        <span class="n">contact_site_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># get closest skeleton nodes</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">a_nearest_sn_ixs</span> <span class="o">=</span> <span class="n">a_skel_node_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">cs_center</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">a_source_node</span> <span class="o">=</span> <span class="n">a_skel_node_list</span><span class="p">[</span><span class="n">a_nearest_sn_ixs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">a_nn</span> <span class="o">=</span> <span class="n">max_nodes_in_path</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a_source_node</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="c1"># get nearest node to source node of skeleton b and average radius</span>
        <span class="n">a_source_node_nn</span> <span class="o">=</span> <span class="n">a_skel_node_list</span><span class="p">[</span><span class="n">a_nearest_sn_ixs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">mean_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">a_source_node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">],</span>
                               <span class="n">a_source_node_nn</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_nn</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="n">csite_name</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;_skelnode&#39;</span><span class="o">+</span>\
                          <span class="s1">&#39;_area </span><span class="si">%0.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">csa_area</span><span class="p">)</span>
                <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;head_diameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_radius</span> <span class="o">*</span> <span class="mi">2</span>
                <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;skel_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="n">csite_name</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;_skelnode</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">j</span>
            <span class="n">curr_node</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">curr_node</span><span class="o">.</span><span class="n">appendComment</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
            <span class="n">contact_site_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
            <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_nn</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">target_node</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getNodeEdges</span><span class="p">(</span><span class="n">node</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">contact_site_anno</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">)</span>
                <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="n">dist</span><span class="p">,</span> <span class="n">b_nearest_sn_ixs</span> <span class="o">=</span> <span class="n">b_skel_node_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">cs_center</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">b_source_node</span> <span class="o">=</span> <span class="n">b_skel_node_list</span><span class="p">[</span><span class="n">b_nearest_sn_ixs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">b_nn</span> <span class="o">=</span> <span class="n">max_nodes_in_path</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b_source_node</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="c1"># get nearest node to source node of skeleton b and average radius</span>
        <span class="n">b_source_node_nn</span> <span class="o">=</span> <span class="n">b_skel_node_list</span><span class="p">[</span><span class="n">b_nearest_sn_ixs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">mean_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">b_source_node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">],</span>
                               <span class="n">b_source_node_nn</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">b_nn</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="n">csite_name</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;_skelnode&#39;</span><span class="o">+</span><span class="s1">&#39;_area </span><span class="si">%0.2f</span><span class="s1">&#39;</span>\
                                <span class="o">%</span> <span class="p">(</span><span class="n">csb_area</span><span class="p">)</span>
                <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;head_diameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_radius</span> <span class="o">*</span> <span class="mi">2</span>
                <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;skel_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="n">csite_name</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;_skelnode</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">j</span>
            <span class="n">curr_node</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">curr_node</span><span class="o">.</span><span class="n">appendComment</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
            <span class="n">contact_site_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
            <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">b_nn</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">target_node</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getNodeEdges</span><span class="p">(</span><span class="n">node</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">contact_site_anno</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">)</span>
                <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                <span class="k">pass</span>
        <span class="n">contact_site_anno</span><span class="o">.</span><span class="n">setComment</span><span class="p">(</span><span class="n">contact_site_name</span><span class="p">)</span>
        <span class="n">dummy_skel</span> <span class="o">=</span> <span class="n">Skeleton</span><span class="p">()</span>
        <span class="n">dummy_skel</span><span class="o">.</span><span class="n">add_annotation</span><span class="p">(</span><span class="n">contact_site_anno</span><span class="p">)</span>
        <span class="n">cs_destpath</span> <span class="o">=</span> <span class="n">dest_path</span>
        <span class="k">if</span> <span class="n">vc_bool</span> <span class="ow">and</span> <span class="n">sj_bool</span><span class="p">:</span>
            <span class="n">cs_destpath</span> <span class="o">+=</span> <span class="s1">&#39;cs_vc_sj/&#39;</span>
        <span class="k">elif</span> <span class="n">vc_bool</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sj_bool</span><span class="p">:</span>
            <span class="n">cs_destpath</span> <span class="o">+=</span> <span class="s1">&#39;cs_vc/&#39;</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">vc_bool</span> <span class="ow">and</span> <span class="n">sj_bool</span><span class="p">:</span>
            <span class="n">cs_destpath</span> <span class="o">+=</span> <span class="s1">&#39;cs_sj/&#39;</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">vc_bool</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sj_bool</span><span class="p">:</span>
            <span class="n">cs_destpath</span> <span class="o">+=</span> <span class="s1">&#39;cs/&#39;</span>
        <span class="n">dummy_skel</span><span class="o">.</span><span class="n">toNml</span><span class="p">(</span><span class="n">cs_destpath</span><span class="o">+</span><span class="n">contact_site_name</span><span class="o">+</span><span class="s1">&#39;.nml&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairwise_anno</span><span class="o">.</span><span class="n">getNodes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># print &quot;Did not found any node in annotation object.&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">pairwise_anno</span><span class="o">.</span><span class="n">appendComment</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">cs&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">csites</span><span class="p">))</span>
    <span class="n">dummy_skel</span> <span class="o">=</span> <span class="n">Skeleton</span><span class="p">()</span>
    <span class="n">dummy_skel</span><span class="o">.</span><span class="n">add_annotation</span><span class="p">(</span><span class="n">pairwise_anno</span><span class="p">)</span>
    <span class="n">dummy_skel</span><span class="o">.</span><span class="n">toNml</span><span class="p">(</span><span class="n">dest_path</span><span class="o">+</span><span class="s1">&#39;pairwise/&#39;</span><span class="o">+</span><span class="n">annotation_name</span><span class="o">+</span><span class="s1">&#39;.nml&#39;</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">dummy_skel</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
    <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="max_nodes_in_path"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.max_nodes_in_path">[docs]</a><span class="k">def</span> <span class="nf">max_nodes_in_path</span><span class="p">(</span><span class="n">anno</span><span class="p">,</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">max_number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find specified number of nodes along skeleton from source node (BFS).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    anno: SkeletonAnnotation</span>
<span class="sd">        tracing on which to search</span>
<span class="sd">    source_node: SkeletonNode</span>
<span class="sd">        Starting node</span>
<span class="sd">    max_number: int</span>
<span class="sd">        Maximum number of nodes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of SkeletonNodes</span>
<span class="sd">        Tracing nodes up to certain distance from source node</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skel_graph</span> <span class="o">=</span> <span class="n">su</span><span class="o">.</span><span class="n">annotation_to_nx_graph</span><span class="p">(</span><span class="n">anno</span><span class="p">)</span>
    <span class="n">reachable_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">source_node</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">bfs_edges</span><span class="p">(</span><span class="n">skel_graph</span><span class="p">,</span> <span class="n">source_node</span><span class="p">):</span>
        <span class="n">next_node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">reachable_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reachable_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max_number</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">reachable_nodes</span></div>


<div class="viewcode-block" id="feature_valid_syns"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.feature_valid_syns">[docs]</a><span class="k">def</span> <span class="nf">feature_valid_syns</span><span class="p">(</span><span class="n">cs_dir</span><span class="p">,</span> <span class="n">only_sj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">only_syn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">all_contacts</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the features of valid synapses predicted by synapse rfc</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cs_dir : str</span>
<span class="sd">        Path to computed contact sites.</span>
<span class="sd">    only_sj : bool</span>
<span class="sd">        Return feature of all contact sites with mapped sj.</span>
<span class="sd">    only_syn : bool</span>
<span class="sd">        Returns feature only if synapse was predicted</span>
<span class="sd">    all_contacts : bool</span>
<span class="sd">        Use all contact sites for feature extraction</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array (n x f), np.array (n x 1), np.array (n x 1)</span>
<span class="sd">        features, array of contact site IDS, boolean array of synapse prediction</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">clf_path</span> <span class="o">=</span> <span class="n">cs_dir</span> <span class="o">+</span> <span class="s1">&#39;/../models/rf_synapses/rfc_syn.pkl&#39;</span>
    <span class="n">cs_fpaths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">only_sj</span><span class="p">:</span>
        <span class="n">search_folder</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cs_sj/&#39;</span><span class="p">,</span> <span class="s1">&#39;cs_vc_sj/&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">all_contacts</span><span class="p">:</span>
        <span class="n">search_folder</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cs_sj/&#39;</span><span class="p">,</span> <span class="s1">&#39;cs_vc_sj/&#39;</span><span class="p">,</span> <span class="s1">&#39;cs/&#39;</span><span class="p">,</span> <span class="s1">&#39;cs_vc/&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">search_folder</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cs/&#39;</span><span class="p">,</span> <span class="s1">&#39;cs_vc/&#39;</span><span class="p">]</span>
    <span class="n">sample_list_len</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ending</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">search_folder</span><span class="p">):</span>
        <span class="n">curr_dir</span> <span class="o">=</span> <span class="n">cs_dir</span><span class="o">+</span><span class="n">ending</span>
        <span class="n">curr_fpaths</span> <span class="o">=</span> <span class="n">get_filepaths_from_dir</span><span class="p">(</span><span class="n">curr_dir</span><span class="p">,</span> <span class="n">ending</span><span class="o">=</span><span class="s1">&#39;nml&#39;</span><span class="p">)</span>
        <span class="n">cs_fpaths</span> <span class="o">+=</span> <span class="n">curr_fpaths</span>
        <span class="n">sample_list_len</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_fpaths</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs_fpaths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="n">nb_cpus</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">nb_cpus</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sample</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">cs_fpaths</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map_async</span><span class="p">(</span><span class="n">readout_cs_info</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    <span class="n">non_instances</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">cs_infos</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">non_instances</span><span class="p">]</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">el</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">cs_infos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">only_sj</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">only_syn</span> <span class="ow">or</span> <span class="n">all_contacts</span><span class="p">:</span>
        <span class="n">syn_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">),</span> <span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rfc_syn</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">clf_path</span><span class="p">)</span>
        <span class="n">syn_pred</span> <span class="o">=</span> <span class="n">rfc_syn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
    <span class="n">axoness_info</span> <span class="o">=</span> <span class="n">cs_infos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">features</span><span class="p">,</span> <span class="n">axoness_info</span><span class="p">,</span> <span class="n">syn_pred</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span></div>


<div class="viewcode-block" id="readout_cs_info"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.readout_cs_info">[docs]</a><span class="k">def</span> <span class="nf">readout_cs_info</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function of feature_valid_syns</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    args: tuple</span>
<span class="sd">        path to file and queue</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array, str</span>
<span class="sd">        synapse features, contact site ID</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cspath</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">args</span>
    <span class="n">feat</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">read_pair_cs</span><span class="p">(</span><span class="n">cspath</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">cs</span><span class="o">.</span><span class="n">getNodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="s1">&#39;center&#39;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">getComment</span><span class="p">():</span>
            <span class="n">feat</span> <span class="o">=</span> <span class="n">parse_synfeature_from_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">feat</span><span class="p">,</span> <span class="n">cs</span><span class="o">.</span><span class="n">getComment</span><span class="p">()</span></div>


<div class="viewcode-block" id="calc_syn_dict"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.calc_syn_dict">[docs]</a><span class="k">def</span> <span class="nf">calc_syn_dict</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">axoness_info</span><span class="p">,</span> <span class="n">get_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates dictionary of synapses. Keys are ids of pre cells and values are</span>
<span class="sd">    dictionaries of corresponding synapses with post cell ids.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    features: np.array</span>
<span class="sd">        synapse feature</span>
<span class="sd">    axoness_info: np.array</span>
<span class="sd">        string containing axoness information of cells</span>
<span class="sd">    get_all : bool</span>
<span class="sd">        collect all contact sites</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array, np.array, dict, np.array, np.array, dict</span>
<span class="sd">        synapse features, axoness information, connectivity,\</span>
<span class="sd">           post synaptic cell ids, synapse predictions, axoness</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axoness_info</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">total_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;No synapse dict to create.&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="p">{},</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">),</span> <span class="p">{}</span>
    <span class="n">ax_ax_cnt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">den_den_cnt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">all_post_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pre_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">val_syn_ixs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">valid_syn_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
    <span class="n">axoness_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ax_info</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axoness_info</span><span class="p">):</span>
        <span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r</span><span class="si">%0.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span> <span class="o">/</span> <span class="n">total_size</span><span class="p">))</span>
        <span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">cell1</span><span class="p">,</span> <span class="n">cell2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;(\d+)axoness(\-?\d+)&#39;</span><span class="p">,</span> <span class="n">ax_info</span><span class="p">)</span>
        <span class="n">cs_nb</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;cs(\d+)&#39;</span><span class="p">,</span> <span class="n">ax_info</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">cell1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cell2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">cell_axoness</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="n">cell1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cell2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">axoness_entry</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">cell1</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="n">cell1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">cell2</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="n">cell2</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
        <span class="n">axoness_dict</span><span class="p">[</span><span class="n">cs_nb</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">cell1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">cell2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">axoness_entry</span>
        <span class="k">if</span> <span class="n">cell_axoness</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_axoness</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">cell_axoness</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ax_ax_cnt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">den_den_cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">valid_syn_array</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">get_all</span><span class="p">:</span>
                    <span class="k">continue</span>
        <span class="n">val_syn_ixs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">pre_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cell_axoness</span><span class="p">)</span>
        <span class="n">pre_id</span> <span class="o">=</span> <span class="n">cell_ids</span><span class="p">[</span><span class="n">pre_ix</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pre_ix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">post_ix</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">post_ix</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">post_id</span> <span class="o">=</span> <span class="n">cell_ids</span><span class="p">[</span><span class="n">post_ix</span><span class="p">]</span>
        <span class="n">all_post_ids</span> <span class="o">+=</span> <span class="p">[</span><span class="n">post_id</span><span class="p">]</span>
        <span class="n">syn_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">syn_dict</span><span class="p">[</span><span class="s1">&#39;post_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">post_id</span>
        <span class="n">syn_dict</span><span class="p">[</span><span class="s1">&#39;post_axoness&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_axoness</span><span class="p">[</span><span class="n">post_ix</span><span class="p">]</span>
        <span class="n">syn_dict</span><span class="p">[</span><span class="s1">&#39;cs_area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">features</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">syn_dict</span><span class="p">[</span><span class="s1">&#39;sj_size_abs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">features</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">syn_dict</span><span class="p">[</span><span class="s1">&#39;sj_size_rel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">features</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pre_id</span> <span class="ow">in</span> <span class="n">pre_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">syns</span> <span class="o">=</span> <span class="n">pre_dict</span><span class="p">[</span><span class="n">pre_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">post_id</span> <span class="ow">in</span> <span class="n">syns</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">syns</span><span class="p">[</span><span class="n">post_id</span><span class="p">][</span><span class="s1">&#39;cs_area&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">features</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">syns</span><span class="p">[</span><span class="n">post_id</span><span class="p">][</span><span class="s1">&#39;sj_size_abs&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">features</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">syns</span><span class="p">[</span><span class="n">post_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">syn_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syns</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">syns</span><span class="p">[</span><span class="n">post_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">syn_dict</span>
            <span class="n">pre_dict</span><span class="p">[</span><span class="n">pre_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">syns</span>
    <span class="k">return</span> <span class="n">features</span><span class="p">[</span><span class="n">val_syn_ixs</span><span class="p">],</span> <span class="n">axoness_info</span><span class="p">[</span><span class="n">val_syn_ixs</span><span class="p">],</span> <span class="n">pre_dict</span><span class="p">,</span>\
           <span class="n">all_post_ids</span><span class="p">,</span> <span class="n">valid_syn_array</span><span class="p">,</span> <span class="n">axoness_dict</span></div>


<div class="viewcode-block" id="cs_btw_annos"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.cs_btw_annos">[docs]</a><span class="k">def</span> <span class="nf">cs_btw_annos</span><span class="p">(</span><span class="n">anno_a</span><span class="p">,</span> <span class="n">anno_b</span><span class="p">,</span> <span class="n">max_hull_dist</span><span class="p">,</span> <span class="n">concom_dist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes contact sites between two annotation objects and returns hull</span>
<span class="sd">    points of both skeletons near contact site.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    anno_a : SkeletonAnnotation</span>
<span class="sd">        Annotation object A</span>
<span class="sd">    anno_b : SkeletonAnnotation</span>
<span class="sd">        Annotation object B</span>
<span class="sd">    max_hull_dist : int</span>
<span class="sd">        Maximum distance between skeletons in nm</span>
<span class="sd">    concom_dist : int</span>
<span class="sd">        maximum distance of connected components (nm)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        List of hull coordinates for each contact site</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hull_a</span> <span class="o">=</span> <span class="n">anno_a</span><span class="o">.</span><span class="n">hull_coords</span>
    <span class="n">hull_b</span> <span class="o">=</span> <span class="n">anno_b</span><span class="o">.</span><span class="n">hull_coords</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hull_a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">hull_b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># print &quot;One skeleton hull is empty!! Skipping pair.&quot;</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">tree_a</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">hull_a</span><span class="p">)</span>
    <span class="n">tree_b</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">hull_b</span><span class="p">)</span>
    <span class="n">contact_ids</span> <span class="o">=</span> <span class="n">tree_a</span><span class="o">.</span><span class="n">query_ball_tree</span><span class="p">(</span><span class="n">tree_b</span><span class="p">,</span> <span class="n">max_hull_dist</span><span class="p">)</span>
    <span class="n">num_neighbours</span> <span class="o">=</span> <span class="n">arr</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">contact_ids</span><span class="p">])</span>
    <span class="n">contact_coords_a</span> <span class="o">=</span> <span class="n">hull_a</span><span class="p">[</span><span class="n">num_neighbours</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">contact_ids_b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">id</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">contact_ids</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">])</span>
    <span class="n">contact_coords_b</span> <span class="o">=</span> <span class="n">hull_b</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">contact_ids_b</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">contact_coords_a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">contact_coords_a</span> <span class="o">=</span> <span class="n">contact_coords_a</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="n">contact_coords_b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">contact_coords_b</span> <span class="o">=</span> <span class="n">contact_coords_a</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">contact_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">contact_coords_a</span><span class="p">,</span> <span class="n">contact_coords_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">contact_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.95</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hull_a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">hull_b</span><span class="p">)):</span>
        <span class="nb">print</span> <span class="s2">&quot;Found too many contact_coords (proportion of total hull voxel:&quot;</span> \
              <span class="s2">&quot;</span><span class="si">%0.3f</span><span class="s2">) assuming similar skeleton comparison between skeleton&quot;</span> \
              <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">. &quot;</span> \
              <span class="o">%</span> <span class="p">(</span><span class="n">contact_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hull_a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">hull_b</span><span class="p">)),</span>
                 <span class="n">anno_a</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">anno_b</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">contact_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">pdists</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">contact_coords</span><span class="p">)</span>
    <span class="n">pdists</span><span class="p">[</span><span class="n">pdists</span> <span class="o">&gt;</span> <span class="n">concom_dist</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pdists</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">pdists</span><span class="p">))</span>
    <span class="n">nb_cc</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">pdists</span><span class="p">)</span>
    <span class="n">cs_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="n">curr_label_ixs</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">label</span>
        <span class="n">cs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contact_coords</span><span class="p">[</span><span class="n">curr_label_ixs</span><span class="p">])</span>
    <span class="c1"># extract annotation ids</span>
    <span class="n">tree_a_b</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">hull_a</span><span class="p">,</span> <span class="n">hull_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">contact_site_coord_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">min_id_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hull_a</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">cs_list</span><span class="p">:</span>
        <span class="c1"># map the contact site to each coordinate</span>
        <span class="n">ids_temp</span> <span class="o">=</span> <span class="n">tree_a_b</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">in_b</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">ids_temp</span><span class="o">&gt;=</span><span class="n">min_id_b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">contact_site_coord_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">in_b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cs_list</span><span class="p">,</span> <span class="n">contact_site_coord_ids</span></div>


<div class="viewcode-block" id="translate_dense_tracings"><a class="viewcode-back" href="../../../syconn.processing.html#syconn.processing.mapper.translate_dense_tracings">[docs]</a><span class="k">def</span> <span class="nf">translate_dense_tracings</span><span class="p">():</span>
    <span class="n">fpaths</span> <span class="o">=</span> <span class="n">get_filepaths_from_dir</span><span class="p">(</span><span class="s1">&#39;/lustre/pschuber/dense_vol_tracings/source/&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">fpaths</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">load_ordered_mapped_skeleton</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">getNodes</span><span class="p">():</span>
            <span class="n">n</span><span class="o">.</span><span class="n">setCoordinate</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">getCoordinate</span><span class="p">()</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3540</span><span class="p">,</span> <span class="mi">4843</span><span class="p">,</span> <span class="mi">2418</span><span class="p">]))</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">dummy_skel</span> <span class="o">=</span> <span class="n">Skeleton</span><span class="p">()</span>
        <span class="n">dummy_skel</span><span class="o">.</span><span class="n">add_annotation</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">dummy_skel</span><span class="o">.</span><span class="n">to_kzip</span><span class="p">(</span><span class="s2">&quot;/lustre/pschuber/SyConnDenseCube/tracings/&quot;</span> <span class="o">+</span>
                           <span class="n">file_name</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SyConn a documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Sven Dorkenwald, Philipp Schubert, JÃ¶rgen Kornfeld.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.8.
    </div>
  </body>
</html>